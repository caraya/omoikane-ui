{"version":3,"file":"prism-DU08x7FD.js","sources":["../src/config.js","../src/util/async.js","../src/core/highlight-all.js","../src/shared/dom-util.js","../src/core/highlight-element.js","../src/core/stringify.js","../src/core/highlight.js","../src/core/linked-list.js","../src/core/tokenize/util.js","../src/core/tokenize/match.js","../src/core/tokenize/tokenize.js","../src/core/classes/hooks.js","../src/core/classes/component-registry.js","../src/util/extend.js","../src/core/classes/list.js","../src/core/classes/language.js","../src/util/grammar-patch.js","../src/core/classes/language-registry.js","../src/core/classes/plugin.js","../src/core/classes/plugin-registry.js","../src/core/classes/prism.js","../src/core/prism.js"],"sourcesContent":["const hasDOM = typeof document !== 'undefined' && typeof window !== 'undefined';\nconst scriptElement = hasDOM ? document.currentScript : null;\n\n/**\n * @type {GlobalConfig}\n */\nconst globalConfig = globalThis.Prism?.constructor?.name === 'Object' ? globalThis.Prism : {};\n\n/**\n * @param {string} name\n */\nfunction getGlobalSetting (name) {\n\t// eslint-disable-next-line regexp/no-unused-capturing-group\n\tconst camelCaseName = name.replace(/-([a-z])/g, g => g[1].toUpperCase());\n\n\tif (camelCaseName in globalConfig) {\n\t\treturn globalConfig[camelCaseName];\n\t}\n\telse if (name in globalConfig) {\n\t\treturn globalConfig[name];\n\t}\n\telse if (hasDOM) {\n\t\treturn (\n\t\t\tscriptElement?.dataset[camelCaseName] ??\n\t\t\tdocument.querySelector(`[data-prism-${name}]`)?.getAttribute(`data-prism-${name}`)\n\t\t);\n\t}\n}\n\n/**\n * @param {string} name\n * @param {boolean} defaultValue\n * @returns {boolean}\n */\nfunction getGlobalBooleanSetting (name, defaultValue) {\n\tconst value = getGlobalSetting(name);\n\n\tif (value === null || value === undefined) {\n\t\treturn defaultValue;\n\t}\n\n\treturn !(value === false || value === 'false');\n}\n\n/**\n * @param {string} name\n * @returns {string[]}\n */\nfunction getGlobalArraySetting (name) {\n\tconst value = getGlobalSetting(name);\n\tif (value === null || value === undefined || value === false || value === 'false') {\n\t\treturn [];\n\t}\n\telse if (typeof value === 'string') {\n\t\treturn value.split(',').map(s => s.trim());\n\t}\n\telse if (Array.isArray(value)) {\n\t\treturn value;\n\t}\n\n\treturn [];\n}\n\n/**\n * @type {PrismConfig}\n */\nexport const globalDefaults = {\n\tmanual: getGlobalBooleanSetting('manual', !hasDOM),\n\tsilent: getGlobalBooleanSetting('silent', false),\n\tlanguages: getGlobalArraySetting('languages'),\n\tplugins: getGlobalArraySetting('plugins'),\n\tlanguagePath: /** @type {string} */ (getGlobalSetting('language-path') ?? './languages/'),\n\tpluginPath: /** @type {string} */ (getGlobalSetting('plugin-path') ?? './plugins/'),\n};\n\nexport default globalDefaults;\n\n/**\n * @import { PrismConfig, GlobalConfig } from './types.d.ts';\n */\n","/**\n * @param {Document} [document=globalThis.document]\n * @returns {Promise<any>}\n */\nexport function documentReady (document = globalThis.document) {\n\tif (!document) {\n\t\treturn Promise.reject();\n\t}\n\n\tconst script = /** @type {HTMLScriptElement | null} */ (document.currentScript);\n\n\t// If the document state is \"loading\", then we'll use DOMContentLoaded.\n\t// If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the\n\t// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they\n\t// might take longer one animation frame to execute which can create a race condition where only some plugins have\n\t// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.\n\t// See https://github.com/PrismJS/prism/issues/2102\n\t// See https://github.com/PrismJS/prism/issues/3535\n\tconst readyState = document.readyState;\n\tif (\n\t\treadyState === 'loading' ||\n\t\t(readyState === 'interactive' && script && script.defer && !script.async)\n\t) {\n\t\treturn new Promise(resolve => {\n\t\t\tdocument.addEventListener('DOMContentLoaded', resolve, { once: true });\n\t\t});\n\t}\n\n\treturn Promise.resolve();\n}\n\nexport function nextTick () {\n\treturn new Promise(resolve => {\n\t\tif (typeof requestAnimationFrame === 'function') {\n\t\t\trequestAnimationFrame(resolve);\n\t\t}\n\t\telse if (typeof setImmediate === 'function') {\n\t\t\tsetImmediate(resolve);\n\t\t}\n\t\telse {\n\t\t\tsetTimeout(resolve, 0);\n\t\t}\n\t});\n}\n\n/**\n * In addition to waiting for all promises to settle, handle post-hoc additions/removals.\n *\n * @template T\n * @param {Promise<T>[]} promises\n * @returns {Promise<(T | null)[]>}\n */\nexport async function allSettled (promises) {\n\treturn Promise.allSettled(promises).then(outcomes => {\n\t\tif (promises.length > 0 && promises.length !== outcomes.length) {\n\t\t\t// The list of promises changed. Return a new Promise.\n\t\t\t// The original promise won't resolve until the new one does.\n\t\t\treturn allSettled(promises);\n\t\t}\n\n\t\t// The list of promises either empty or stayed the same.\n\t\t// Return results immediately.\n\t\treturn outcomes.map(o => (o.status === 'fulfilled' ? o.value : null));\n\t});\n}\n\n/**\n * @template T\n * @typedef {Promise<T> & {resolve: (value: T) => void, reject: (reason?: any) => void}} DeferredPromise<T>\n *\n */\n\n/**\n * @template T\n * @returns {DeferredPromise<T>}\n */\nexport function defer () {\n\t/**\n\t * @type {DeferredPromise<T>['resolve']}\n\t */\n\tlet res;\n\n\t/**\n\t * @type {DeferredPromise<T>['reject']}\n\t */\n\tlet rej;\n\n\tconst promise = /** @type {DeferredPromise<T>} */ (\n\t\tnew Promise((resolve, reject) => {\n\t\t\tres = resolve;\n\t\t\trej = reject;\n\t\t})\n\t);\n\n\t// @ts-ignore\n\tpromise.resolve = res;\n\t// @ts-ignore\n\tpromise.reject = rej;\n\n\treturn promise;\n}\n","import singleton from './prism.js';\n\n/**\n * This is the most high-level function in Prism's API.\n * It queries all the elements that have a `.language-xxxx` class and then calls {@link Prism#highlightElement} on\n * each one of them.\n *\n * The following hooks will be run:\n * 1. `before-highlightall`\n * 2. `before-all-elements-highlight`\n * 3. All hooks of {@link Prism#highlightElement} for each element.\n *\n * @this {Prism}\n * @param {HighlightAllOptions} [options={}]\n */\nexport function highlightAll (options = {}) {\n\tconst prism = this ?? singleton;\n\tconst { root, async, callback } = options;\n\n\t/** @type {HookEnv} */\n\tconst env = {\n\t\tcallback,\n\t\troot: root ?? document,\n\t\tselector:\n\t\t\t'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code',\n\t};\n\n\tprism.hooks.run('before-highlightall', env);\n\n\tenv.elements = [...env.root.querySelectorAll(env.selector)];\n\n\tprism.hooks.run('before-all-elements-highlight', env);\n\n\tfor (const element of env.elements) {\n\t\tprism.highlightElement(element, { async, callback: env.callback });\n\t}\n}\n\n/**\n * @import { Prism } from './prism.js';\n * @import { HookEnv } from '../types.d.ts';\n * @import { AsyncHighlighter } from './highlight-element.js';\n */\n\n/**\n * @typedef {object} HighlightAllOptions\n * @property {ParentNode} [root] The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n * @property {AsyncHighlighter} [async]\n * @property {(element: Element) => void} [callback] An optional callback to be invoked on each element after its highlighting is done. @see HighlightElementOptionsCallback\n */\n","const lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n\n/**\n * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n *\n * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n *\n * @param {Element} element\n * @returns {string}\n */\nexport function getLanguage (element) {\n\t/** @type {Element | null} */\n\tlet e = element;\n\tfor (; e; e = e.parentElement) {\n\t\tconst m = lang.exec(e.className);\n\t\tif (m) {\n\t\t\treturn m[1].toLowerCase();\n\t\t}\n\t}\n\treturn 'none';\n}\n\n/**\n * Sets the Prism `language-xxxx` class of the given element.\n *\n * @param {Element} element\n * @param {string} language\n * @returns {void}\n */\nexport function setLanguage (element, language) {\n\t// remove all `language-xxxx` classes\n\t// (this might leave behind a leading space)\n\telement.className = element.className.replace(RegExp(lang, 'gi'), '');\n\n\t// add the new `language-xxxx` class\n\t// (using `classList` will automatically clean up spaces for us)\n\telement.classList.add('language-' + language);\n}\n\n/**\n * Returns whether a given class is active for `element`.\n *\n * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n * given class is just the given class with a `no-` prefix.\n *\n * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n * ancestors have the given class or the negated version of it, then the default activation will be returned.\n *\n * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n * version of it, the class is considered active.\n *\n * @param {Element | null} element\n * @param {string} className\n * @param {boolean} [defaultActivation=false] Defaults to `false`.\n * @returns {boolean}\n */\nexport function isActive (element, className, defaultActivation = false) {\n\treturn (\n\t\telement?.closest(`.${className}, .no-${className}`)?.classList?.contains(className) ??\n\t\tdefaultActivation\n\t);\n}\n\n/**\n * If the parent element of the given element is a `<pre>` element, then it\n * will be returned. Otherwise, `undefined` will be returned.\n *\n * @param {Element} element\n * @returns {HTMLPreElement | undefined}\n */\nexport function getParentPre (element) {\n\tconst pre = element.parentElement;\n\tif (pre && /pre/i.test(pre.nodeName)) {\n\t\treturn /** @type {HTMLPreElement} */ (pre);\n\t}\n\treturn undefined;\n}\n","import { getLanguage, setLanguage } from '../shared/dom-util.js';\nimport { htmlEncode } from '../shared/util.js';\nimport singleton from './prism.js';\n\n/**\n * Highlights the code inside a single element.\n *\n * The following hooks will be run:\n * 1. `before-sanity-check`\n * 2. `before-highlight`\n * 3. All hooks of {@link Prism#highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n * 4. `before-insert`\n * 5. `after-highlight`\n * 6. `complete`\n *\n * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n * the element's language.\n *\n * @this {Prism}\n * @param {Element} element The element containing the code. It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n * @param {HighlightElementOptions} [options={}]\n */\nexport function highlightElement (element, options = {}) {\n\tconst prism = this ?? singleton;\n\tconst { async, callback } = options;\n\n\t// Find language\n\tconst language = getLanguage(element);\n\tconst grammar = prism.languageRegistry.getLanguage(language)?.resolvedGrammar;\n\n\t// Set language on the element, if not present\n\tsetLanguage(element, language);\n\n\t// Set language on the parent, for styling\n\tlet parent = element.parentElement;\n\tif (parent && parent.nodeName.toLowerCase() === 'pre') {\n\t\tsetLanguage(parent, language);\n\t}\n\n\tconst code = element.textContent;\n\n\t/** @type {HookEnv} */\n\tconst env = {\n\t\telement,\n\t\tlanguage,\n\t\tgrammar,\n\t\tcode,\n\t};\n\n\t/**\n\t * @param {string} highlightedCode\n\t */\n\tconst insertHighlightedCode = highlightedCode => {\n\t\tenv.highlightedCode = highlightedCode;\n\t\tprism.hooks.run('before-insert', env);\n\n\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\tprism.hooks.run('after-highlight', env);\n\t\tprism.hooks.run('complete', env);\n\t\tcallback?.(env.element);\n\t};\n\n\tprism.hooks.run('before-sanity-check', env);\n\n\t// plugins may change/add the parent/element\n\tparent = env.element.parentElement;\n\tif (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {\n\t\tparent.setAttribute('tabindex', '0');\n\t}\n\n\tif (!env.code) {\n\t\tprism.hooks.run('complete', env);\n\t\tcallback?.(env.element);\n\t\treturn;\n\t}\n\n\tprism.hooks.run('before-highlight', env);\n\n\tif (!env.grammar) {\n\t\tinsertHighlightedCode(htmlEncode(env.code));\n\t\treturn;\n\t}\n\n\tif (async) {\n\t\tasync({\n\t\t\tlanguage: env.language,\n\t\t\tcode: env.code,\n\t\t\tgrammar: env.grammar,\n\t\t}).then(insertHighlightedCode, prism.config.errorHandler);\n\t}\n\telse {\n\t\tinsertHighlightedCode(prism.highlight(env.code, env.language, { grammar: env.grammar }));\n\t}\n}\n\n/**\n * @import { Prism } from './prism.js';\n * @import { HookEnv, Grammar } from '../types.d.ts';\n */\n\n/**\n * @typedef {object} HighlightElementOptions\n * @property {AsyncHighlighter} [async]\n * @property {HighlightElementOptionsCallback} [callback]\n */\n\n/**\n * An optional callback to be invoked after the highlighting is done.\n * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n *\n * @callback HighlightElementOptionsCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n */\n\n/**\n * @typedef {object} AsyncHighlightingData\n * @property {string} language\n * @property {string} code\n * @property {Grammar} grammar\n */\n\n/**\n * @callback AsyncHighlighter\n * @param {AsyncHighlightingData} data\n * @returns {Promise<string>}\n */\n","import { htmlEncode } from '../shared/util.js';\n\n/**\n * Converts the given token or token stream to an HTML representation.\n *\n * The following hooks will be run:\n * 1. `wrap`: On each {@link Token}.\n *\n * @param {string | Token | TokenStream} o The token or token stream to be converted.\n * @param {string} language The name of current language.\n * @param {Hooks} hooks\n * @returns {string} The HTML representation of the token or token stream.\n */\nfunction stringify (o, language, hooks) {\n\tif (typeof o === 'string') {\n\t\treturn htmlEncode(o);\n\t}\n\tif (Array.isArray(o)) {\n\t\tlet s = '';\n\t\to.forEach(e => {\n\t\t\ts += stringify(e, language, hooks);\n\t\t});\n\t\treturn s;\n\t}\n\n\t/** @type {HookEnv} */\n\tconst env = {\n\t\ttype: o.type,\n\t\tcontent: stringify(o.content, language, hooks),\n\t\ttag: 'span',\n\t\tclasses: ['token', o.type],\n\t\tattributes: {},\n\t\tlanguage,\n\t};\n\n\tconst aliases = o.alias;\n\tif (aliases) {\n\t\tif (Array.isArray(aliases)) {\n\t\t\tenv.classes.push(...aliases);\n\t\t}\n\t\telse {\n\t\t\tenv.classes.push(aliases);\n\t\t}\n\t}\n\n\thooks.run('wrap', env);\n\n\tlet attributes = '';\n\tfor (const name in env.attributes) {\n\t\tattributes +=\n\t\t\t' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n\t}\n\n\treturn (\n\t\t'<' +\n\t\tenv.tag +\n\t\t' class=\"' +\n\t\tenv.classes.join(' ') +\n\t\t'\"' +\n\t\tattributes +\n\t\t'>' +\n\t\tenv.content +\n\t\t'</' +\n\t\tenv.tag +\n\t\t'>'\n\t);\n}\n\nexport { stringify };\nexport default stringify;\n\n/**\n * @typedef {import('../types.d.ts').HookEnv} HookEnv\n * @typedef {import('./classes/hooks.js').Hooks} Hooks\n * @typedef {import('./classes/token.js').Token} Token\n * @typedef {import('../types.d.ts').TokenStream} TokenStream\n */\n","import singleton from './prism.js';\nimport stringify from './stringify.js';\n\n/**\n * Low-level function, only use if you know what you're doing. It accepts a string of text as input\n * and the language definitions to use, and returns a string with the HTML produced.\n *\n * The following hooks will be run:\n * 1. `before-tokenize`\n * 2. `after-tokenize`\n * 3. `wrap`: On each {@link Token}.\n *\n * @this {Prism}\n * @param {string} text A string with the code to be highlighted.\n * @param {string} language The name of the language definition passed to `grammar`.\n * @param {HighlightOptions} [options] An object containing the tokens to use.\n *\n * Usually a language definition like `Prism.languages.markup`.\n * @returns {string} The highlighted HTML.\n * @example\n * Prism.highlight('var foo = true;', 'javascript');\n */\nexport function highlight (text, language, options) {\n\tconst prism = this ?? singleton;\n\n\tconst grammar =\n\t\toptions?.grammar ?? prism.languageRegistry.getLanguage(language)?.resolvedGrammar;\n\n\t/** @type {HookEnv} */\n\tconst env = {\n\t\tcode: text,\n\t\tgrammar,\n\t\tlanguage,\n\t};\n\tprism.hooks.run('before-tokenize', env);\n\tif (!env.grammar) {\n\t\tthrow new Error('The language \"' + env.language + '\" has no grammar.');\n\t}\n\n\tenv.tokens = prism.tokenize(env.code, env.grammar);\n\tprism.hooks.run('after-tokenize', env);\n\n\treturn stringify(env.tokens, env.language, prism.hooks);\n}\n\n/**\n * @import { Prism } from './prism.js';\n * @import { HookEnv, Grammar } from '../types.d.ts';\n */\n\n/**\n * @typedef {object} HighlightOptions\n * @property {Grammar} [grammar]\n */\n","/**\n * @template T\n */\nexport class LinkedList {\n\t/**\n\t * @template T\n\t * @type {LinkedListHeadNode<T>}\n\t */\n\thead;\n\n\t/**\n\t * @template T\n\t * @type {LinkedListTailNode<T>}\n\t */\n\ttail;\n\n\t/** @type {number} */\n\tlength;\n\n\tconstructor () {\n\t\t/**\n\t\t * @type {LinkedListHeadNode<T>}\n\t\t */\n\t\tconst head = { value: null, prev: null, next: /** @type {any} */ (null) };\n\n\t\t/**\n\t\t * @type {LinkedListTailNode<T>}\n\t\t */\n\t\tconst tail = { value: null, prev: head, next: null };\n\t\thead.next = tail;\n\n\t\tthis.head = head;\n\t\tthis.tail = tail;\n\t\tthis.length = 0;\n\t}\n\n\t/**\n\t * Adds a new node with the given value to the list.\n\t *\n\t * @param {LinkedListHeadNode<T> | LinkedListMiddleNode<T>} node\n\t * @param {T} value\n\t * @returns {LinkedListMiddleNode<T>}\n\t */\n\taddAfter (node, value) {\n\t\t// assumes that node != list.tail && values.length >= 0\n\t\tconst next = node.next;\n\n\t\t/** @type {LinkedListMiddleNode<T>} */\n\t\tconst newNode = { value, prev: node, next };\n\t\tnode.next = newNode;\n\t\tnext.prev = newNode;\n\t\tthis.length++;\n\n\t\treturn newNode;\n\t}\n\n\t/**\n\t * Removes `count` nodes after the given node. The given node will not be removed.\n\t *\n\t * @param {LinkedListHeadNode<T> | LinkedListMiddleNode<T>} node\n\t * @param {number} count\n\t */\n\tremoveRange (node, count) {\n\t\tlet next = node.next;\n\t\tlet i = 0;\n\t\tfor (; i < count && next.next !== null; i++) {\n\t\t\tnext = next.next;\n\t\t}\n\t\tnode.next = next;\n\t\tnext.prev = node;\n\t\tthis.length -= i;\n\t}\n\n\t/**\n\t * @returns {T[]}\n\t */\n\ttoArray () {\n\t\tconst array = [];\n\t\tlet node = this.head.next;\n\t\twhile (node.next !== null) {\n\t\t\tarray.push(node.value);\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn array;\n\t}\n}\n\n/**\n * @template T\n * @typedef {object} LinkedListHeadNode\n * @property {null} value\n * @property {null} prev\n * @property {LinkedListMiddleNode<T> | LinkedListTailNode<T>} next\n */\n/**\n * @template T\n * @typedef {object} LinkedListMiddleNode\n * @property {T} value\n * @property {LinkedListMiddleNode<T> | LinkedListHeadNode<T>} prev\n * @property {LinkedListMiddleNode<T> | LinkedListTailNode<T>} next\n */\n\n/**\n * @template T\n * @typedef {object} LinkedListTailNode\n * @property {null} value\n * @property {LinkedListMiddleNode<T> | LinkedListHeadNode<T>} prev\n * @property {null} next\n */\n","import singleton from '../prism.js';\n\n/**\n * @this {Prism}\n * @param {Grammar | string | null | undefined} reference\n * @returns {Grammar | undefined}\n */\nexport function resolve (reference) {\n\tconst prism = this ?? singleton;\n\tlet ret = reference ?? undefined;\n\n\tif (typeof ret === 'string') {\n\t\tret = prism.languageRegistry.getLanguage(ret)?.resolvedGrammar;\n\t}\n\n\tif (typeof ret === 'object' && ret.$rest) {\n\t\tconst restGrammar = resolve.call(prism, ret.$rest) ?? {};\n\t\tif (typeof restGrammar === 'object') {\n\t\t\tret = { ...ret, ...restGrammar };\n\t\t}\n\n\t\tdelete ret.$rest;\n\t}\n\n\treturn /** @type {Grammar | undefined} */ (ret);\n}\n\n/**\n * @import { Prism } from '../prism.js';\n * @import { Grammar, LanguageRegistry } from '../../types.d.ts';\n */\n","import { Token } from '../classes/token.js';\nimport singleton from '../prism.js';\nimport { tokenize } from './tokenize.js';\nimport { resolve } from './util.js';\n\n/**\n * @this {Prism}\n * @param {string} text\n * @param {LinkedList<string | Token>} tokenList\n * @param {GrammarTokens} grammar\n * @param {LinkedListHeadNode<string | Token> | LinkedListMiddleNode<string | Token>} startNode\n * @param {number} startPos\n * @param {RematchOptions} [rematch]\n * @returns {void}\n */\nexport function _matchGrammar (text, tokenList, grammar, startNode, startPos, rematch) {\n\tconst prism = this ?? singleton;\n\n\t// @ts-ignore\n\tgrammar = resolve.call(prism, grammar);\n\n\tfor (const token in grammar) {\n\t\tconst tokenValue = grammar[token];\n\t\tif (!grammar.hasOwnProperty(token) || token.startsWith('$') || !tokenValue) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst patterns = Array.isArray(tokenValue) ? tokenValue : [tokenValue];\n\n\t\tfor (let j = 0; j < patterns.length; ++j) {\n\t\t\tif (rematch && rematch.cause === `${token},${j}`) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst patternObj = toGrammarToken(patterns[j]);\n\t\t\tlet { pattern, lookbehind = false, greedy = false, alias, inside } = patternObj;\n\t\t\tconst insideGrammar = resolve.call(prism, inside);\n\n\t\t\tif (greedy && !pattern.global) {\n\t\t\t\t// Without the global flag, lastIndex won't work\n\t\t\t\tpatternObj.pattern = pattern = RegExp(pattern.source, pattern.flags + 'g');\n\t\t\t}\n\n\t\t\tfor (\n\t\t\t\t// iterate the token list and keep track of the current token/string position\n\t\t\t\tlet currentNode = startNode.next, pos = startPos;\n\t\t\t\tcurrentNode.next !== null;\n\t\t\t\tpos += currentNode.value.length, currentNode = currentNode.next\n\t\t\t) {\n\t\t\t\tif (rematch && pos >= rematch.reach) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlet str = currentNode.value;\n\n\t\t\t\tif (tokenList.length > text.length) {\n\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet removeCount = 1; // this is the to parameter of removeBetween\n\t\t\t\tlet match;\n\n\t\t\t\tif (greedy) {\n\t\t\t\t\tmatch = matchPattern(pattern, pos, text, lookbehind);\n\t\t\t\t\tif (!match || match.index >= text.length) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst from = match.index;\n\t\t\t\t\tconst to = match.index + match[0].length;\n\t\t\t\t\tlet p = pos;\n\n\t\t\t\t\t// find the node that contains the match\n\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\twhile (from >= p) {\n\t\t\t\t\t\tcurrentNode = currentNode.next;\n\t\t\t\t\t\tif (currentNode.next === null) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t'The linked list and the actual text have become de-synced'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t}\n\t\t\t\t\t// adjust pos (and p)\n\t\t\t\t\tp -= currentNode.value.length;\n\t\t\t\t\tpos = p;\n\n\t\t\t\t\t// the current node is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\tif (currentNode.value instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// find the last node which is affected by this match\n\t\t\t\t\t/** @type {LinkedListMiddleNode<string | Token> | LinkedListTailNode<string | Token>} */\n\t\t\t\t\tlet k = currentNode;\n\t\t\t\t\tfor (; k.next !== null && (p < to || typeof k.value === 'string'); k = k.next) {\n\t\t\t\t\t\tremoveCount++;\n\t\t\t\t\t\tp += k.value.length;\n\t\t\t\t\t}\n\t\t\t\t\tremoveCount--;\n\n\t\t\t\t\t// replace with the new match\n\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmatch = matchPattern(pattern, 0, str, lookbehind);\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst from = match.index;\n\t\t\t\tconst matchStr = match[0];\n\t\t\t\tconst before = str.slice(0, from);\n\t\t\t\tconst after = str.slice(from + matchStr.length);\n\n\t\t\t\tconst reach = pos + str.length;\n\t\t\t\tif (rematch && reach > rematch.reach) {\n\t\t\t\t\trematch.reach = reach;\n\t\t\t\t}\n\n\t\t\t\tlet removeFrom = currentNode.prev;\n\n\t\t\t\tif (before) {\n\t\t\t\t\tremoveFrom = tokenList.addAfter(removeFrom, before);\n\t\t\t\t\tpos += before.length;\n\t\t\t\t}\n\n\t\t\t\ttokenList.removeRange(removeFrom, removeCount);\n\n\t\t\t\tconst wrapped = new Token(\n\t\t\t\t\ttoken,\n\t\t\t\t\tinsideGrammar\n\t\t\t\t\t\t? tokenize.call(prism, matchStr, /** @type {Grammar} */ (insideGrammar))\n\t\t\t\t\t\t: matchStr,\n\t\t\t\t\talias,\n\t\t\t\t\tmatchStr\n\t\t\t\t);\n\t\t\t\tcurrentNode = tokenList.addAfter(removeFrom, wrapped);\n\n\t\t\t\tif (after) {\n\t\t\t\t\ttokenList.addAfter(currentNode, after);\n\t\t\t\t}\n\n\t\t\t\tif (removeCount > 1) {\n\t\t\t\t\t// at least one Token object was removed, so we have to do some rematching\n\t\t\t\t\t// this can only happen if the current pattern is greedy\n\n\t\t\t\t\t/** @type {RematchOptions} */\n\t\t\t\t\tconst nestedRematch = {\n\t\t\t\t\t\tcause: `${token},${j}`,\n\t\t\t\t\t\treach,\n\t\t\t\t\t};\n\t\t\t\t\t_matchGrammar.call(\n\t\t\t\t\t\tprism,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t\ttokenList,\n\t\t\t\t\t\tgrammar,\n\t\t\t\t\t\tcurrentNode.prev,\n\t\t\t\t\t\tpos,\n\t\t\t\t\t\tnestedRematch\n\t\t\t\t\t);\n\n\t\t\t\t\t// the reach might have been extended because of the rematching\n\t\t\t\t\tif (rematch && nestedRematch.reach > rematch.reach) {\n\t\t\t\t\t\trematch.reach = nestedRematch.reach;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {RegExp} pattern\n * @param {number} pos\n * @param {string} text\n * @param {boolean} lookbehind\n */\nfunction matchPattern (pattern, pos, text, lookbehind) {\n\tpattern.lastIndex = pos;\n\tconst match = pattern.exec(text);\n\tif (match && lookbehind && match[1]) {\n\t\t// change the match to remove the text matched by the Prism lookbehind group\n\t\tconst lookbehindLength = match[1].length;\n\t\tmatch.index += lookbehindLength;\n\t\tmatch[0] = match[0].slice(lookbehindLength);\n\t}\n\treturn match;\n}\n\n/**\n * @param {GrammarToken | RegExpLike} pattern\n * @returns {GrammarToken}\n */\nfunction toGrammarToken (pattern) {\n\tif (!pattern.pattern) {\n\t\treturn { pattern };\n\t}\n\telse {\n\t\treturn pattern;\n\t}\n}\n\n/**\n * @typedef {object} RematchOptions\n * @property {string} cause\n * @property {number} reach\n */\n\n/**\n * @import { Prism } from '../prism.js';\n * @import { Grammar, GrammarToken, GrammarTokens, RegExpLike } from '../../types.d.ts';\n */\n\n/**\n * @template T\n * @typedef {import('../../core/linked-list.js').LinkedList<T>} LinkedList\n */\n\n/**\n * @template T\n * @typedef {import('../../core/linked-list.js').LinkedListHeadNode<T>} LinkedListHeadNode\n */\n\n/**\n * @template T\n * @typedef {import('../../core/linked-list.js').LinkedListMiddleNode<T>} LinkedListMiddleNode\n */\n\n/**\n * @template T\n * @typedef {import('../../core/linked-list.js').LinkedListTailNode<T>} LinkedListTailNode\n */\n","import { LinkedList } from '../linked-list.js';\nimport singleton from '../prism.js';\nimport { _matchGrammar } from './match.js';\n\n/**\n * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n * and the language definitions to use, and returns an array with the tokenized code.\n *\n * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n *\n * This method could be useful in other contexts as well, as a very crude parser.\n *\n * @this {Prism}\n * @param {string} text A string with the code to be highlighted.\n * @param {Grammar} grammar An object containing the tokens to use.\n *\n * Usually a language definition like `Prism.languages.markup`.\n * @returns {TokenStream} An array of strings and tokens, a token stream.\n * @example\n * let code = `var foo = 0;`;\n * let tokens = Prism.tokenize(code, Prism.getLanguage('javascript'));\n * tokens.forEach(token => {\n *     if (token instanceof Token && token.type === 'number') {\n *         console.log(`Found numeric literal: ${token.content}`);\n *     }\n * });\n */\nexport function tokenize (text, grammar) {\n\tconst prism = this ?? singleton;\n\tconst customTokenize = grammar.$tokenize;\n\tif (customTokenize) {\n\t\treturn customTokenize(text, grammar, prism);\n\t}\n\n\tconst tokenList = new LinkedList();\n\ttokenList.addAfter(tokenList.head, text);\n\n\t_matchGrammar.call(\n\t\tprism,\n\t\ttext,\n\t\ttokenList,\n\t\t/** @type {GrammarTokens} */ (grammar),\n\t\ttokenList.head,\n\t\t0\n\t);\n\n\treturn tokenList.toArray();\n}\n\n/**\n * @import { TokenStream, Grammar, GrammarTokens } from '../../types.d.ts';\n * @import { Prism } from '../prism.js';\n */\n","/**\n * A class for managing hooks for deep extensibility.\n * Inspired by https://www.npmjs.com/package/blissful-hooks.\n */\nexport class Hooks {\n\t/**\n\t * Private internal map of hook names to arrays of callback functions.\n\t *\n\t * @type {HooksAll}\n\t */\n\t_all = {};\n\n\t/**\n\t * Adds the given callback to the list of callbacks for the given hook and returns a function that\n\t * removes the hook again when called.\n\t *\n\t * The callback will be invoked when the hook it is registered for is run.\n\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n\t *\n\t * One callback function can be registered to multiple hooks.\n\t *\n\t * A callback function must not be registered for the same hook multiple times. Doing so will cause\n\t * undefined behavior. However, registering a callback again after removing it is fine.\n\t *\n\t * @type {HooksAdd}\n\t * @param name Hook name(s) or a map of hook names to callbacks.\n\t * @param callback The callback function which is given environment variables.\n\t * @returns Function that removes the callback when called.\n\t */\n\tadd (name, callback) {\n\t\tif (Array.isArray(name)) {\n\t\t\t// One function, multiple hooks\n\t\t\tfor (const n of name) {\n\t\t\t\tthis.add(n, callback);\n\t\t\t}\n\t\t}\n\t\telse if (typeof name === 'object') {\n\t\t\t// Multiple hooks\n\t\t\tconst hooks = name;\n\n\t\t\tfor (const name in hooks) {\n\t\t\t\tconst callback = hooks[name];\n\t\t\t\tif (callback) {\n\t\t\t\t\tthis.add(/** @type {string} */ (name), /** @type {HookCallback} */ (callback));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tconst hooks = (this._all[name] ??= []);\n\t\t\thooks.push(/** @type {never} */ (callback));\n\t\t}\n\n\t\treturn () => {\n\t\t\tthis.remove(name, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Removes the given callback from the list of callbacks for the given hook(s).\n\t *\n\t * @type {HooksRemove}\n\t * @param name Hook name(s) or a map of hook names to callbacks.\n\t * @param callback The callback function to remove.\n\t */\n\tremove (name, callback) {\n\t\tif (Array.isArray(name)) {\n\t\t\t// Multiple hook names, same callback\n\t\t\tfor (const n of name) {\n\t\t\t\tthis.remove(n, callback);\n\t\t\t}\n\t\t}\n\t\telse if (typeof name === 'object') {\n\t\t\t// Map of hook names to callbacks\n\t\t\tfor (const n in name) {\n\t\t\t\tthis.remove(n, callback);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tconst index = this._all[name]?.indexOf(/** @type {never} */ (callback));\n\t\t\tif (index > -1) {\n\t\t\t\tthis._all[name].splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t *\n\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t *\n\t * @type {HooksRun}\n\t * @param name The name of the hook.\n\t * @param env The environment variables of the hook passed to all callbacks registered.\n\t */\n\trun (name, env) {\n\t\tconst callbacks = this._all[name];\n\t\tconst context = env?.this ?? env?.context ?? env;\n\n\t\tif (!callbacks || !callbacks.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback.call(context, env);\n\t\t}\n\t}\n}\n\n/**\n * @typedef {import('../../types.d.ts').HookCallback} HookCallback\n * @typedef {import('../../types.d.ts').HooksAll} HooksAll\n * @typedef {import('../../types.d.ts').HooksAdd} HooksAdd\n * @typedef {import('../../types.d.ts').HooksRemove} HooksRemove\n * @typedef {import('../../types.d.ts').HooksRun} HooksRun\n */\n","import { allSettled } from '../../util/async.js';\n\n/**\n * @template {ComponentProto} T\n */\nexport default class ComponentRegistry extends EventTarget {\n\tstatic type = 'unknown';\n\n\t/**\n\t * All imported components.\n\t *\n\t * @type {Record<string, T>}\n\t */\n\tcache = {};\n\n\t/**\n\t * All components that are currently being loaded.\n\t *\n\t * @type {Record<string, Promise<T>>}\n\t */\n\tloading = {};\n\n\t/**\n\t * Same data as in loading, but as an array, used for aggregate promises.\n\t * IMPORTANT: Do NOT overwrite this array, only modify its contents.\n\t *\n\t * @type {Promise<T>[]}\n\t */\n\t#loadingList = [];\n\n\t/**\n\t * @type {Promise<T[]>}\n\t */\n\tready;\n\n\t/**\n\t * Path to the components, used for loading.\n\t *\n\t * @type {string}\n\t */\n\tpath;\n\n\t/**\n\t * A reference to the Prism instance.\n\t *\n\t * @type {Prism}\n\t */\n\tprism;\n\n\t/**\n\t * @type {ComponentRegistryOptions}\n\t */\n\toptions;\n\n\t/**\n\t *\n\t * @param {ComponentRegistryOptions} options\n\t */\n\tconstructor (options) {\n\t\tsuper();\n\n\t\tthis.options = options;\n\t\tlet { path, preload, prism } = options;\n\n\t\tthis.prism = prism;\n\n\t\tpath = path.endsWith('/') ? path : path + '/';\n\t\tthis.path = path;\n\n\t\tif (preload) {\n\t\t\tvoid this.loadAll(preload);\n\t\t}\n\n\t\tthis.ready = /** @type {Promise<T[]>} */ (allSettled(this.#loadingList));\n\t}\n\n\t/**\n\t * Returns the component if it is already loaded or a promise that resolves when it is loaded,\n\t * without triggering a load like `load()` would.\n\t *\n\t * @param {string} id\n\t * @returns {Promise<T>}\n\t */\n\tasync whenDefined (id) {\n\t\tif (this.cache[id]) {\n\t\t\t// Already loaded\n\t\t\treturn this.cache[id];\n\t\t}\n\n\t\tif (this.loading[id] !== undefined) {\n\t\t\t// Already loading\n\t\t\treturn this.loading[id];\n\t\t}\n\n\t\tconst Self = /** @type {typeof ComponentRegistry} */ (this.constructor);\n\t\treturn new Promise(resolve => {\n\t\t\t/**\n\t\t\t * @param {CustomEvent<AddEventPayload<T>>} e\n\t\t\t */\n\t\t\tconst handler = e => {\n\t\t\t\tif (e.detail.id === id) {\n\t\t\t\t\tresolve(e.detail.component);\n\t\t\t\t\tthis.removeEventListener('add', /** @type {EventListener} */ (handler));\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.addEventListener('add' + Self.type, /** @type {EventListener} */ (handler));\n\t\t});\n\t}\n\n\t/**\n\t * Add a component to the registry.\n\t *\n\t * @param {T} def Component\n\t * @param {string} [id=def.id] Component id\n\t * @param {object} [options] Options\n\t * @param {boolean} [options.force] Force add the component even if it is already present\n\t * @returns {boolean} true if the component was added, false if it was already present\n\t */\n\tadd (def, id = def.id, options) {\n\t\tconst Self = /** @type {typeof ComponentRegistry} */ (this.constructor);\n\n\t\tif (typeof this.loading[id] !== 'undefined') {\n\t\t\t// If it was loading, remove it from the loading list\n\t\t\tconst index = this.#loadingList.indexOf(this.loading[id]);\n\t\t\tif (index > -1) {\n\t\t\t\tthis.#loadingList.splice(index, 1);\n\t\t\t}\n\n\t\t\tdelete this.loading[id];\n\t\t}\n\n\t\tif (!this.cache[id] || options?.force) {\n\t\t\tthis.cache[id] = def;\n\n\t\t\tthis.dispatchEvent(\n\t\t\t\t/** @type {CustomEvent<AddEventPayload<T>>} */\n\t\t\t\tnew CustomEvent('add', {\n\t\t\t\t\tdetail: { id, type: Self.type, component: def },\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.dispatchEvent(\n\t\t\t\t/** @type {CustomEvent<AddEventPayload<T>>} */\n\t\t\t\tnew CustomEvent('add' + Self.type, {\n\t\t\t\t\tdetail: { id, component: def },\n\t\t\t\t})\n\t\t\t);\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t *\n\t * @param {string} id\n\t * @returns {boolean}\n\t */\n\thas (id) {\n\t\treturn this.cache[id] !== undefined;\n\t}\n\n\t/**\n\t *\n\t * @param {string} id\n\t * @returns {T | null}\n\t */\n\tget (id) {\n\t\treturn this.cache[id] ?? null;\n\t}\n\n\t/**\n\t *\n\t * @param {string} id\n\t * @returns {T | Promise<T | null>}\n\t */\n\tload (id) {\n\t\tif (this.cache[id]) {\n\t\t\treturn this.cache[id];\n\t\t}\n\n\t\tif (this.loading[id] !== undefined) {\n\t\t\t// Already loading\n\t\t\treturn this.loading[id];\n\t\t}\n\n\t\tconst loadingComponent = import(this.path + id + '.js')\n\t\t\t.then(m => {\n\t\t\t\t/** @type {T} */\n\t\t\t\tconst component = m.default ?? m;\n\t\t\t\tthis.add(component, id);\n\t\t\t\treturn component;\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\tconsole.error(error);\n\t\t\t\treturn null;\n\t\t\t});\n\n\t\tthis.loading[id] = /** @type {Promise<T>} */ (loadingComponent);\n\t\tthis.#loadingList.push(/** @type {Promise<T>} */ (loadingComponent));\n\t\treturn loadingComponent;\n\t}\n\n\t/**\n\t *\n\t * @param {string[]} ids\n\t * @returns {(T | Promise<T | null>)[]}\n\t */\n\tloadAll (ids) {\n\t\tif (!Array.isArray(ids)) {\n\t\t\tids = [ids];\n\t\t}\n\n\t\treturn ids.map(id => this.load(id));\n\t}\n}\n\n/**\n * @import {Prism} from '../prism.js'\n * @import {ComponentProto} from '../../types.d.ts'\n */\n\n/**\n * @typedef {object} ComponentRegistryOptions\n * @property {string} path Path to the components\n * @property {string[]} [preload] List of component ids to preload\n * @property {Prism} prism A reference to the Prism instance\n */\n\n/**\n * @template {ComponentProto} T\n * @typedef {object} AddEventPayload\n * @property {string} id\n * @property {string} [type]\n * @property {T} component\n */\n","import { betterAssign, deepClone } from './objects.js';\n\n/**\n * Creates a deep copy of the language with the given id and appends the given tokens.\n *\n * If a token in `reDef` also appears in the copied language, then the existing token in the copied language\n * will be overwritten at its original position.\n *\n * ## Best practices\n *\n * Since the position of overwriting tokens (token in `reDef` that overwrite tokens in the copied language)\n * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n *\n * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n *\n * @param {Grammar} base The grammar of the language to extend.\n * @param {Grammar} grammar The new tokens to append.\n * @returns {Grammar} The new language created.\n * @example\n * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n *     // at its original position\n *     'comment': { ... },\n *     // CSS doesn't have a 'color' token, so this token will be appended\n *     'color': /\\b(?:red|green|blue)\\b/\n * });\n */\nexport function extend (base, grammar) {\n\tconst lang = deepClone(base);\n\n\tfor (const key in grammar) {\n\t\tif (typeof key !== 'string' || key.startsWith('$')) {\n\t\t\t// ignore special keys\n\t\t\tcontinue;\n\t\t}\n\n\t\tlang[key] = grammar[key];\n\t}\n\n\tif (grammar.$insertBefore) {\n\t\tlang.$insertBefore = betterAssign(lang.$insertBefore ?? {}, grammar.$insertBefore);\n\t}\n\n\tif (grammar.$insertAfter) {\n\t\tlang.$insertAfter = betterAssign(lang.$insertAfter ?? {}, grammar.$insertAfter);\n\t}\n\n\tif (grammar.$insert) {\n\t\t// Syntactic sugar for $insertBefore/$insertAfter\n\t\tfor (const tokenName in grammar.$insert) {\n\t\t\tconst def = grammar.$insert[tokenName];\n\t\t\tconst { $before, $after, ...token } = def;\n\t\t\tconst relToken = $before || $after;\n\t\t\tconst all = $before ? '$insertBefore' : '$insertAfter';\n\t\t\tlang[all] ??= {};\n\n\t\t\tif (Array.isArray(relToken)) {\n\t\t\t\t// Insert in multiple places\n\t\t\t\tfor (const t of relToken) {\n\t\t\t\t\tlang[all][t][tokenName] = token;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (relToken) {\n\t\t\t\t(lang[all][relToken] ??= {})[tokenName] = token;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlang[tokenName] = token;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (grammar.$delete) {\n\t\tif (lang.$delete) {\n\t\t\t// base also had $delete\n\t\t\tlang.$delete.push(...grammar.$delete);\n\t\t}\n\t\telse {\n\t\t\tlang.$delete = [...grammar.$delete];\n\t\t}\n\t}\n\n\tif (grammar.$merge) {\n\t\tlang.$merge = betterAssign(lang.$merge ?? {}, grammar.$merge);\n\t}\n\n\treturn lang;\n}\n\n/**\n * @typedef {import('../types.d.ts').Grammar} Grammar\n */\n","import { toIterable } from '../../util/iterables.js';\n\n/**\n * Set with some conveniences.\n *\n * @template T\n */\nexport default class List extends Set {\n\t/**\n\t * Alias of `size` so these objects can be handled like arrays\n\t */\n\tget length () {\n\t\treturn this.size;\n\t}\n\n\t/**\n\t * @param {Iterable<T> | T} arg\n\t * @returns\n\t */\n\taddAll (arg) {\n\t\tif (!arg) {\n\t\t\treturn this;\n\t\t}\n\n\t\tfor (const item of toIterable(arg)) {\n\t\t\tthis.add(item);\n\t\t}\n\n\t\treturn this;\n\t}\n}\n","import { extend } from '../../shared.js';\nimport { grammarPatch } from '../../util/grammar-patch.js';\nimport { deepClone, defineLazyProperty } from '../../util/objects.js';\nimport List from './list.js';\n\nexport default class Language extends EventTarget {\n\t/** @type {LanguageProto} */\n\tdef;\n\n\t/** @type {LanguageRegistry} */\n\tregistry;\n\n\t/** @type {List<Language | LanguageProto>} */\n\trequire = new List();\n\n\t/** @type {List<string | Language | LanguageProto>} */\n\toptional = new List();\n\n\t/** @type {LanguageGrammars} */\n\tlanguages = {};\n\n\treadyState = 0;\n\n\t/**\n\t *\n\t * @param {LanguageProto} def\n\t * @param {LanguageRegistry} registry\n\t */\n\tconstructor (def, registry) {\n\t\tsuper();\n\t\tthis.def = def;\n\t\tthis.registry = registry;\n\n\t\tif (this.def.base) {\n\t\t\tthis.require.add(this.def.base);\n\t\t}\n\t\tif (this.def.require) {\n\t\t\tthis.require.addAll(/** @type {LanguageProto | LanguageProto[]} */ (this.def.require));\n\t\t}\n\n\t\tif (this.def.optional) {\n\t\t\tthis.optional.addAll(this.def.optional);\n\n\t\t\tif (this.optional.size > 0) {\n\t\t\t\tfor (const optionalLanguageId of this.optional) {\n\t\t\t\t\tif (!this.registry.has(optionalLanguageId)) {\n\t\t\t\t\t\tthis.registry.whenDefined(optionalLanguageId).then(() => {\n\t\t\t\t\t\t\t// TODO\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const def of this.require) {\n\t\t\t// Ensure all required languages are registered, but not necessarily resolved yet\n\t\t\tthis.registry.add(def);\n\n\t\t\tdefineLazyProperty(this.languages, def.id, () => {\n\t\t\t\tconst language = this.registry.peek(def);\n\t\t\t\tif (language) {\n\t\t\t\t\t// Already resolved\n\t\t\t\t\treturn language.resolvedGrammar;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn this.registry.getLanguage(def.id).resolvedGrammar;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfor (const id of this.optional) {\n\t\t\t// TODO: we need to update the grammar\n\t\t\tdefineLazyProperty(\n\t\t\t\tthis.languages,\n\t\t\t\tid,\n\t\t\t\t() => {\n\t\t\t\t\treturn this.registry.getLanguage(id).resolvedGrammar;\n\t\t\t\t},\n\t\t\t\tthis.registry.peek(id) ?? this.registry.whenDefined(id)\n\t\t\t);\n\t\t}\n\t}\n\n\tresolve () {}\n\n\tget id () {\n\t\treturn this.def.id;\n\t}\n\n\tget alias () {\n\t\tif (!this.def.alias) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn Array.isArray(this.def.alias) ? this.def.alias : [this.def.alias];\n\t}\n\n\t/**\n\t * @returns {Language | null}\n\t */\n\tget base () {\n\t\tif (!this.def.base) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst base = this.def.base;\n\t\tconst language = this.registry.peek(base);\n\t\tif (language) {\n\t\t\t// Already resolved\n\t\t\treturn language;\n\t\t}\n\t\telse {\n\t\t\treturn this.registry.getLanguage(base.id);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Grammar}\n\t */\n\tget grammar () {\n\t\t// Lazily evaluate grammar\n\t\tconst def = this.def;\n\n\t\tlet { grammar } = def;\n\t\tconst base = this.base;\n\n\t\tif (typeof grammar === 'function') {\n\t\t\tconst options = {\n\t\t\t\t...(base && {\n\t\t\t\t\tget base () {\n\t\t\t\t\t\treturn base.resolvedGrammar;\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\tlanguages: this.languages,\n\n\t\t\t\t/**\n\t\t\t\t * @param {string} id\n\t\t\t\t * @param {Grammar} ref\n\t\t\t\t */\n\t\t\t\textend: (id, ref) => extend(this.languages[id], ref),\n\n\t\t\t\t/**\n\t\t\t\t * @param {string} id\n\t\t\t\t */\n\t\t\t\tgetOptionalLanguage: id => {\n\t\t\t\t\tconst language = this.languages[id] ?? this.registry.getLanguage(id);\n\t\t\t\t\treturn language?.resolvedGrammar ?? language;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * @param {string} id\n\t\t\t\t */\n\t\t\t\twhenDefined: id => {\n\t\t\t\t\treturn this.registry.whenDefined(id);\n\t\t\t\t},\n\t\t\t};\n\t\t\tgrammar = grammar.call(this, /** @type {any} */ (options));\n\t\t}\n\n\t\tif (base) {\n\t\t\tgrammar = extend(base.grammar, grammar);\n\t\t}\n\n\t\tif (def.grammar === grammar) {\n\t\t\t// We need these to be separate so that any code modifying them doesn't affect other instances\n\t\t\tgrammar = deepClone(grammar);\n\t\t}\n\n\t\t// This will replace the getter with a writable property\n\t\t// @ts-ignore\n\t\treturn (this.grammar = grammar);\n\t}\n\n\t/**\n\t * @param {Grammar} grammar\n\t */\n\tset grammar (grammar) {\n\t\tthis.readyState = 2;\n\t\tObject.defineProperty(this, 'grammar', { value: grammar, writable: true });\n\t}\n\n\tget resolvedGrammar () {\n\t\tconst ret = grammarPatch(this.grammar);\n\t\treturn (this.resolvedGrammar = ret);\n\t}\n\n\t/**\n\t * @param {Grammar} grammar\n\t */\n\tset resolvedGrammar (grammar) {\n\t\tthis.readyState = 3;\n\t\tObject.defineProperty(this, 'resolvedGrammar', { value: grammar, writable: true });\n\t}\n}\n\n/** @import { LanguageGrammars, LanguageProto, LanguageRegistry, Grammar } from '../../types.d.ts' */\n","import { insertAfter, insertBefore } from './insert.js';\nimport { deepMerge } from './objects.js';\n\n/**\n * Apply a patch to a grammar to modify it.\n * The patch and the grammar may be the same object.\n *\n * @param {Grammar} grammar\n * @param {Grammar} [patch=grammar]\n * @returns {Grammar}\n */\nexport function grammarPatch (grammar, patch = grammar) {\n\tif (patch.$insertBefore) {\n\t\tfor (const key in patch.$insertBefore) {\n\t\t\tconst tokens = patch.$insertBefore[key];\n\n\t\t\tif (key?.includes('/')) {\n\t\t\t\t// Deep key\n\t\t\t\tlet path = key.split('/');\n\t\t\t\tconst lastKey = path.pop();\n\t\t\t\tpath = path.flatMap(key => [key, 'inside']); // add `inside` after each key\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst obj = path.reduce((acc, key) => acc?.[key], grammar);\n\n\t\t\t\tif (obj) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tinsertBefore(obj, lastKey, tokens);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (tokens) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tinsertBefore(grammar, key, tokens);\n\t\t\t}\n\t\t}\n\t\tdelete grammar.$insertBefore;\n\t}\n\n\tif (patch.$insertAfter) {\n\t\tfor (const key in patch.$insertAfter) {\n\t\t\tconst tokens = patch.$insertAfter[key];\n\n\t\t\tif (key?.includes('/')) {\n\t\t\t\t// Deep key\n\t\t\t\tlet path = key.split('/');\n\t\t\t\tconst lastKey = path.pop();\n\t\t\t\tpath = path.flatMap(key => [key, 'inside']); // add `inside` after each key\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst obj = path.reduce((acc, key) => acc?.[key], grammar);\n\n\t\t\t\tif (obj) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tinsertAfter(obj, lastKey, tokens);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (tokens) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tinsertAfter(grammar, key, tokens);\n\t\t\t}\n\t\t}\n\t\tdelete grammar.$insertAfter;\n\t}\n\n\tif (patch.$delete) {\n\t\t// @ts-ignore\n\t\tfor (const key of patch.$delete) {\n\t\t\t// TODO support deep keys\n\t\t\tdelete grammar[key];\n\t\t}\n\t\tdelete grammar.$delete;\n\t}\n\n\tif (patch.$merge) {\n\t\tfor (const key in patch.$merge) {\n\t\t\tconst tokens = patch.$merge[key];\n\n\t\t\tif (grammar[key]) {\n\t\t\t\tdeepMerge(grammar[key], tokens);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrammar[key] = /** @type {GrammarTokens} */ (tokens);\n\t\t\t}\n\t\t}\n\n\t\tdelete grammar.$merge;\n\t}\n\n\treturn grammar;\n}\n\n/**\n * @typedef {import('../types.d.ts').Grammar} Grammar\n * @typedef {import('../types.d.ts').GrammarTokens} GrammarTokens\n */\n","import ComponentRegistry from './component-registry.js';\nimport Language from './language.js';\n\nexport default class LanguageRegistry extends ComponentRegistry {\n\tstatic type = 'language';\n\n\t/** @type {Record<string, string>} */\n\taliases = {};\n\n\t/** @type {Languages} */\n\tinstances = {};\n\n\t/** @type {WeakMap<LanguageProto, Language>} */\n\tdefs = new WeakMap();\n\n\t/**\n\t * Add a language definition to the registry.\n\t * This does not necessarily resolve the language.\n\t *\n\t * @param {LanguageProto} def\n\t * @returns {boolean}\n\t */\n\tadd (def) {\n\t\tconst added = super.add(def);\n\n\t\tif (added) {\n\t\t\tif (def.alias) {\n\t\t\t\tconst id = def.id;\n\n\t\t\t\tif (typeof def.alias === 'string') {\n\t\t\t\t\tthis.aliases[def.alias] = id;\n\t\t\t\t}\n\t\t\t\telse if (Array.isArray(def.alias)) {\n\t\t\t\t\tfor (const alias of def.alias) {\n\t\t\t\t\t\tthis.aliases[alias] = id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdef.effect?.(this.prism);\n\t\t}\n\n\t\treturn added;\n\t}\n\n\t/**\n\t * @param {string | LanguageProto | Language} ref\n\t * @returns { {\n\t\t\tid: string;\n\t\t\tdef: LanguageProto;\n\t\t\tlanguage?: Language;\n\t\t} }\n\t */\n\tresolveRef (ref) {\n\t\tif (ref instanceof Language) {\n\t\t\treturn { id: ref.id, def: ref.def, language: ref };\n\t\t}\n\n\t\t/** @type {string} */\n\t\tlet id;\n\n\t\t/** @type {LanguageProto} */\n\t\tlet def;\n\n\t\tif (typeof ref === 'object') {\n\t\t\tdef = ref;\n\t\t\tid = def.id;\n\t\t}\n\t\telse if (typeof ref === 'string') {\n\t\t\tid = ref;\n\t\t}\n\t\telse {\n\t\t\tthrow new Error(`Invalid argument type: ${ref}`);\n\t\t}\n\n\t\tid = this.aliases[id] ?? id;\n\t\tdef ??= this.cache[id];\n\t\tconst language = this.instances[id];\n\n\t\treturn { id, def, language };\n\t}\n\n\t/**\n\t * Get resolved language, language definition or null if it doesn't exist.\n\t * If definition is loaded but not yet resolved, it will NOT be resolved. Use {@link getLanguage} for that.\n\t *\n\t * @param {string | Language | LanguageProto} ref Language id or definition\n\t * @returns {Language | null}\n\t */\n\tpeek (ref) {\n\t\tconst { id, def, language } = this.resolveRef(ref);\n\n\t\tif (language) {\n\t\t\treturn language;\n\t\t}\n\n\t\tif (this.defs.has(def)) {\n\t\t\treturn this.defs.get(def) ?? null;\n\t\t}\n\n\t\tif (this.instances[id]) {\n\t\t\treturn this.instances[id];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get resolved language or null if it doesn't exist\n\t * If definition is loaded but not yet resolved, it will be resolved and returned.\n\t *\n\t * @param {string | Language | LanguageProto} ref\n\t * @returns {Language | null}\n\t */\n\tgetLanguage (ref) {\n\t\tconst languageOrDef = this.peek(ref);\n\n\t\tif (languageOrDef instanceof Language) {\n\t\t\treturn languageOrDef;\n\t\t}\n\n\t\tconst { id, def } = this.resolveRef(ref);\n\n\t\tif (!this.cache[id]) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// NOTE: this will overwrite any existing language with the same id\n\t\t// We can add an option to prevent this in the future\n\t\tconst language = new Language(def, this);\n\t\tthis.defs.set(def, language);\n\t\tthis.instances[def.id] = language;\n\t\treturn language;\n\t}\n}\n\n/** @import { LanguageProto, Languages } from '../../types.d.ts' */\n","import List from './list.js';\n\nexport default class Plugin extends EventTarget {\n\t/** @type {PluginProto} */\n\tdef;\n\n\t/** @type {PluginRegistry} */\n\tregistry;\n\n\t/** @type {List<ComponentProto>} */\n\trequire = new List();\n\n\t/**\n\t * @param {PluginProto} def\n\t * @param {PluginRegistry} registry\n\t */\n\tconstructor (def, registry) {\n\t\tsuper();\n\t\tthis.def = def;\n\t\tthis.registry = registry;\n\n\t\tif (this.def.require) {\n\t\t\tthis.require.addAll(this.def.require);\n\t\t}\n\n\t\tfor (const def of this.require) {\n\t\t\t// Ensure all required plugins and languages are registered\n\t\t\tif (def.grammar) {\n\t\t\t\t// We have a language definition\n\t\t\t\tthis.registry.prism.languageRegistry.add(def);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.registry.add(def);\n\t\t\t}\n\t\t}\n\t}\n\n\tget id () {\n\t\treturn this.def.id;\n\t}\n\n\tget plugin () {\n\t\tif (!this.def.plugin) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// This will replace the getter with a writable property\n\t\treturn (this.plugin = this.def.plugin(this.registry.prism));\n\t}\n\n\tset plugin (value) {\n\t\tObject.defineProperty(this, 'plugin', { value, writable: true });\n\t}\n\n\tget effect () {\n\t\treturn this.def.effect;\n\t}\n}\n\n/** @import {ComponentProto, PluginProto, PluginRegistry} from '../../types.d.ts'; */\n","import ComponentRegistry from './component-registry.js';\nimport Plugin from './plugin.js';\n\nexport default class PluginRegistry extends ComponentRegistry {\n\tstatic type = 'plugin';\n\n\t/** @type {Plugins} */\n\tinstances = {};\n\n\t/** @type {WeakMap<PluginProto, Plugin>} */\n\tdefs = new WeakMap();\n\n\t/**\n\t * Add a plugin definition to the registry.\n\t *\n\t * @param {PluginProto} def\n\t * @returns {boolean}\n\t */\n\tadd (def) {\n\t\tconst added = super.add(def);\n\n\t\tif (added) {\n\t\t\tconst plugin = new Plugin(def, this);\n\n\t\t\tthis.defs.set(def, plugin);\n\t\t\tthis.instances[def.id] = plugin;\n\n\t\t\tplugin.effect?.(this.prism);\n\t\t}\n\n\t\treturn added;\n\t}\n\n\t/**\n\t * Get plugin, plugin definition or null if it doesn't exist.\n\t *\n\t * @param {string | Plugin | PluginProto} ref Plugin id or definition\n\t * @returns {Plugin | null}\n\t * @throws {Error} If the argument type is invalid\n\t */\n\tpeek (ref) {\n\t\tif (ref instanceof Plugin) {\n\t\t\treturn ref;\n\t\t}\n\n\t\tif (typeof ref === 'object') {\n\t\t\treturn this.defs.get(ref) ?? null;\n\t\t}\n\t\telse if (typeof ref === 'string') {\n\t\t\treturn this.instances[ref] ?? null;\n\t\t}\n\t\telse {\n\t\t\tthrow new Error(`Invalid argument type: ${ref}`);\n\t\t}\n\t}\n}\n\n/** @import { PluginProto, Plugins } from '../../types.d.ts'; */\n","import globalDefaults from '../../config.js';\nimport { allSettled, documentReady, nextTick } from '../../util/async.js';\nimport { highlightAll } from '../highlight-all.js';\nimport { highlightElement } from '../highlight-element.js';\nimport { highlight } from '../highlight.js';\nimport { tokenize } from '../tokenize/tokenize.js';\nimport { Hooks } from './hooks.js';\nimport LanguageRegistry from './language-registry.js';\nimport PluginRegistry from './plugin-registry.js';\n\n/**\n * Prism class, to create Prism instances with different settings.\n * In most use cases, you just need the pre-existing Prism instance, see {@link prism}.\n */\nexport default class Prism {\n\t/**\n\t * @type {Hooks}\n\t */\n\thooks = new Hooks();\n\n\t/**\n\t * @type {LanguageRegistry}\n\t */\n\tlanguageRegistry;\n\n\t/**\n\t * @type {PluginRegistry}\n\t */\n\tpluginRegistry;\n\n\t/**\n\t * @type {PrismConfig}\n\t */\n\tconfig = globalDefaults;\n\n\t/**\n\t * @type {Promise<unknown>[]}\n\t */\n\twaitFor = [nextTick()];\n\n\t/**\n\t * @type {Promise<unknown>}\n\t */\n\tready = allSettled(this.waitFor);\n\n\t/**\n\t * @param {PrismConfig} [config={}]\n\t */\n\tconstructor (config = {}) {\n\t\tthis.config = Object.assign({}, globalDefaults, config);\n\n\t\tthis.config.errorHandler ??= /** @type {PrismConfig['errorHandler']} */ (\n\t\t\tthis.config.silent ? () => undefined : console.error\n\t\t);\n\n\t\tconst reportError = this.config.errorHandler;\n\n\t\tthis.languageRegistry = new LanguageRegistry({\n\t\t\tpath: /** @type {string} */ (this.config.languagePath),\n\t\t\tpreload: this.config.languages,\n\t\t\tprism: this,\n\t\t});\n\n\t\tthis.pluginRegistry = new PluginRegistry({\n\t\t\tpath: /** @type {string} */ (this.config.pluginPath),\n\t\t\tprism: this,\n\t\t});\n\n\t\tthis.languagesReady = this.languageRegistry.ready;\n\t\tthis.waitFor.push(this.languagesReady);\n\n\t\t// Preload plugins\n\t\tconst plugins = this.config.plugins;\n\t\tif (plugins && plugins.length > 0) {\n\t\t\tconst pluginsReady = this.languagesReady\n\t\t\t\t.then(() => this.waitFor.push(...this.pluginRegistry.loadAll(plugins)))\n\t\t\t\t.catch(reportError);\n\t\t\tthis.waitFor.push(pluginsReady);\n\t\t}\n\n\t\tif (!this.config.manual) {\n\t\t\tthis.waitFor.push(documentReady());\n\n\t\t\tthis.ready.then(() => this.highlightAll()).catch(reportError);\n\t\t}\n\t}\n\n\tget languages () {\n\t\treturn this.languageRegistry.cache;\n\t}\n\n\tget plugins () {\n\t\treturn this.pluginRegistry.cache;\n\t}\n\n\t/**\n\t * Load a language by its id.\n\t *\n\t * @param {string} id\n\t * @returns {Promise<Language | LanguageProto | null>}\n\t */\n\tasync loadLanguage (id) {\n\t\tconst language = await this.languageRegistry.load(id);\n\n\t\treturn language;\n\t}\n\n\t/**\n\t * Load a plugin by its id.\n\t *\n\t * @param {string} id\n\t * @returns {Promise<PluginProto | null>}\n\t */\n\tasync loadPlugin (id) {\n\t\tawait this.languagesReady; // first, wait for any pending languages to load\n\t\tconst plugin = await this.pluginRegistry.load(id);\n\n\t\treturn plugin;\n\t}\n\n\t/**\n\t * See {@link highlightAll}.\n\t *\n\t * @param {HighlightAllOptions} [options]\n\t */\n\thighlightAll (options = {}) {\n\t\treturn highlightAll.call(this, options);\n\t}\n\n\t/**\n\t * See {@link highlightElement}\n\t *\n\t * @param {Element} element\n\t * @param {HighlightElementOptions} [options]\n\t */\n\thighlightElement (element, options = {}) {\n\t\treturn highlightElement.call(this, element, options);\n\t}\n\n\t/**\n\t * See {@link highlight}\n\t *\n\t * @param {string} text\n\t * @param {string} language\n\t * @param {HighlightOptions} [options]\n\t * @returns {string}\n\t */\n\thighlight (text, language, options = {}) {\n\t\treturn highlight.call(this, text, language, options);\n\t}\n\n\t/**\n\t * See {@link tokenize}\n\t *\n\t * @param {string} text\n\t * @param {Grammar} grammar\n\t * @returns {TokenStream}\n\t */\n\ttokenize (text, grammar) {\n\t\treturn tokenize.call(this, text, grammar);\n\t}\n}\n\n/**\n * @import { HighlightAllOptions } from '../highlight-all.js';\n * @import { HighlightElementOptions } from '../highlight-element.js';\n * @import { HighlightOptions } from '../highlight.js';\n * @import { PrismConfig, PluginProto, Language, LanguageProto, Grammar, TokenStream } from '../../types.d.ts';\n */\n","/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me> and contributors <https://github.com/PrismJS/prism/graphs/contributors>\n */\nimport Prism from './classes/prism.js';\n\n/**\n * Prism singleton.\n * This will always be available, and will automatically read config options.\n * This instance of Prism is unique. Even if this module is imported from\n * different sources, the same Prism instance will be returned.\n * In global builds, it will also be the Prism global variable.\n * Any imported plugins and languages will automatically be added to this instance.\n */\nconst prism = new Prism();\nexport default prism;\n\n/** See {@link Prism} */\nexport { Prism };\n"],"names":["hasDOM","document","window","scriptElement","currentScript","globalConfig","globalThis","Prism","constructor","name","getGlobalSetting","camelCaseName","replace","g","toUpperCase","dataset","querySelector","getAttribute","getGlobalBooleanSetting","defaultValue","value","getGlobalArraySetting","split","map","s","trim","Array","isArray","globalDefaults","manual","silent","languages","plugins","languagePath","pluginPath","nextTick","Promise","resolve","requestAnimationFrame","setImmediate","setTimeout","async","allSettled","promises","then","outcomes","length","o","status","highlightAll","options","prism","this","singleton","root","callback","env","selector","hooks","run","elements","querySelectorAll","element","highlightElement","lang","getLanguage","e","parentElement","m","exec","className","toLowerCase","setLanguage","language","RegExp","classList","add","isActive","defaultActivation","closest","contains","getParentPre","pre","test","nodeName","grammar","languageRegistry","resolvedGrammar","parent","code","textContent","insertHighlightedCode","highlightedCode","innerHTML","hasAttribute","setAttribute","config","errorHandler","highlight","htmlEncode","stringify","forEach","type","content","tag","classes","attributes","aliases","alias","push","join","text","Error","tokens","tokenize","LinkedList","head","tail","prev","next","addAfter","node","newNode","removeRange","count","i","toArray","array","reference","ret","undefined","$rest","restGrammar","call","_matchGrammar","tokenList","startNode","startPos","rematch","token","tokenValue","hasOwnProperty","startsWith","patterns","j","cause","patternObj","toGrammarToken","pattern","lookbehind","greedy","inside","insideGrammar","global","source","flags","currentNode","pos","reach","str","Token","match","removeCount","matchPattern","index","from","to","p","k","slice","matchStr","before","after","removeFrom","wrapped","nestedRematch","lastIndex","lookbehindLength","customTokenize","$tokenize","Hooks","_all","n","remove","indexOf","splice","callbacks","context","ComponentRegistry","EventTarget","static","cache","loading","loadingList","ready","path","super","preload","endsWith","loadAll","whenDefined","id","Self","handler","detail","component","removeEventListener","addEventListener","def","force","dispatchEvent","CustomEvent","has","get","load","loadingComponent","import","default","catch","error","console","ids","extend","base","deepClone","key","$insertBefore","betterAssign","$insertAfter","$insert","tokenName","$before","$after","relToken","all","t","$delete","$merge","List","Set","size","addAll","arg","item","toIterable","Language","registry","require","optional","readyState","optionalLanguageId","defineLazyProperty","peek","ref","getOptionalLanguage","Object","defineProperty","writable","patch","includes","lastKey","pop","flatMap","obj","reduce","acc","insertBefore","insertAfter","deepMerge","grammarPatch","LanguageRegistry","instances","defs","WeakMap","added","effect","resolveRef","languageOrDef","set","Plugin","plugin","PluginRegistry","pluginRegistry","waitFor","assign","reportError","languagesReady","pluginsReady","reject","script","defer","once","documentReady","loadLanguage","loadPlugin"],"mappings":"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"}