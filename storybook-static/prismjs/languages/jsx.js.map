{"version":3,"file":"jsx.js","sources":["../../src/languages/jsx.js"],"sourcesContent":["import { getTextContent, Token } from '../core/classes/token.js';\nimport { insertBefore, withoutTokenize } from '../util/language-util.js';\nimport javascript from './javascript.js';\nimport markup from './markup.js';\n\n/**\n * @param {string | Token | TokenStream | undefined} token\n * @returns {string}\n */\nfunction stringifyToken (token) {\n\tif (!token) {\n\t\treturn '';\n\t}\n\telse {\n\t\treturn getTextContent(token);\n\t}\n}\n\n/**\n *\n * @param {TokenStream} tokens\n * @returns {void}\n */\nfunction walkTokens (tokens) {\n\tconst openedTags = [];\n\tfor (let i = 0; i < tokens.length; i++) {\n\t\tconst token = tokens[i];\n\t\tconst isToken = typeof token !== 'string';\n\t\tlet notTagNorBrace = false;\n\n\t\tif (isToken) {\n\t\t\tconst nestedTag = token.content[1];\n\t\t\tif (token.type === 'tag' && typeof nestedTag === 'object' && nestedTag.type === 'tag') {\n\t\t\t\t// We found a tag, now find its kind\n\n\t\t\t\tconst firstChild = token.content[0];\n\t\t\t\tif (typeof firstChild === 'object' && firstChild.content === '</') {\n\t\t\t\t\t// Closing tag\n\t\t\t\t\tif (\n\t\t\t\t\t\topenedTags.length > 0 &&\n\t\t\t\t\t\topenedTags[openedTags.length - 1].tagName === stringifyToken(nestedTag)\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Pop matching opening tag\n\t\t\t\t\t\topenedTags.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst lastChild = token.content[token.content.length - 1];\n\t\t\t\t\tif (typeof lastChild === 'object' && lastChild.content === '/>') {\n\t\t\t\t\t\t// Autoclosed tag, ignore\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Opening tag\n\t\t\t\t\t\topenedTags.push({\n\t\t\t\t\t\t\ttagName: stringifyToken(nestedTag),\n\t\t\t\t\t\t\topenedBraces: 0,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (\n\t\t\t\topenedTags.length > 0 &&\n\t\t\t\ttoken.type === 'punctuation' &&\n\t\t\t\ttoken.content === '{'\n\t\t\t) {\n\t\t\t\t// Here we might have entered a JSX context inside a tag\n\t\t\t\topenedTags[openedTags.length - 1].openedBraces++;\n\t\t\t}\n\t\t\telse if (\n\t\t\t\topenedTags.length > 0 &&\n\t\t\t\topenedTags[openedTags.length - 1].openedBraces > 0 &&\n\t\t\t\ttoken.type === 'punctuation' &&\n\t\t\t\ttoken.content === '}'\n\t\t\t) {\n\t\t\t\t// Here we might have left a JSX context inside a tag\n\t\t\t\topenedTags[openedTags.length - 1].openedBraces--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnotTagNorBrace = true;\n\t\t\t}\n\t\t}\n\t\tif (notTagNorBrace || !isToken) {\n\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n\t\t\t\t// Here we are inside a tag, and not inside a JSX context.\n\t\t\t\t// That's plain text: drop any tokens matched.\n\t\t\t\tlet plainText = stringifyToken(token);\n\n\t\t\t\t// And merge text with adjacent text\n\t\t\t\t/** @type {Token | string | undefined} */\n\t\t\t\tconst next = tokens[i + 1];\n\t\t\t\tif (next && (typeof next === 'string' || next.type === 'plain-text')) {\n\t\t\t\t\tplainText += stringifyToken(next);\n\t\t\t\t\ttokens.splice(i + 1, 1);\n\t\t\t\t}\n\t\t\t\t/** @type {Token | string | undefined} */\n\t\t\t\tconst prev = tokens[i - 1];\n\t\t\t\tif (prev && (typeof prev === 'string' || prev.type === 'plain-text')) {\n\t\t\t\t\tplainText = stringifyToken(prev) + plainText;\n\t\t\t\t\ttokens.splice(i - 1, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t\t\ttokens[i] = new Token('plain-text', plainText, undefined, plainText);\n\t\t\t}\n\t\t}\n\n\t\tif (isToken && typeof token.content !== 'string') {\n\t\t\twalkTokens(token.content);\n\t\t}\n\t}\n}\n\n/** @type {import('../types.d.ts').LanguageProto<'jsx'>} */\nexport default {\n\tid: 'jsx',\n\trequire: [markup, javascript],\n\tgrammar ({ extend }) {\n\t\tconst space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source;\n\t\tconst braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source;\n\t\tlet spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source;\n\n\t\t/**\n\t\t *\n\t\t * @param {string} source\n\t\t * @param {string} [flags]\n\t\t * @returns {RegExp}\n\t\t */\n\t\tfunction re (source, flags) {\n\t\t\tsource = source\n\t\t\t\t.replace(/<S>/g, () => space)\n\t\t\t\t.replace(/<BRACES>/g, () => braces)\n\t\t\t\t.replace(/<SPREAD>/g, () => spread);\n\t\t\treturn RegExp(source, flags);\n\t\t}\n\n\t\tspread = re(spread).source;\n\n\t\tconst javascript = extend('javascript', {});\n\t\tconst jsx = extend('markup', javascript);\n\n\t\tconst tag =\n\t\t\t/** @type {GrammarToken & {inside: Grammar & {tag: GrammarToken & { inside: Grammar };'attr-value': GrammarToken;};}} */ (\n\t\t\t\tjsx.tag\n\t\t\t);\n\t\ttag.pattern = re(\n\t\t\t/<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/\n\t\t\t\t.source\n\t\t);\n\n\t\ttag.inside['tag'].pattern = /^(<\\/?)[^\\s>\\/]*/;\n\t\ttag.inside['attr-value'].pattern =\n\t\t\t/=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/;\n\t\ttag.inside['tag'].inside['class-name'] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n\t\ttag.inside['comment'] = javascript['comment'];\n\n\t\tinsertBefore(tag.inside, 'attr-name', {\n\t\t\t'spread': {\n\t\t\t\tpattern: re(/<SPREAD>/.source),\n\t\t\t\tinside: 'jsx',\n\t\t\t},\n\t\t});\n\n\t\tinsertBefore(tag.inside, 'special-attr', {\n\t\t\t'script': {\n\t\t\t\t// Allow for two levels of nesting\n\t\t\t\tpattern: re(/=<BRACES>/.source),\n\t\t\t\talias: 'language-javascript',\n\t\t\t\tinside: /** @type {Grammar} */ ({\n\t\t\t\t\t'script-punctuation': {\n\t\t\t\t\t\tpattern: /^=(?=\\{)/,\n\t\t\t\t\t\talias: 'punctuation',\n\t\t\t\t\t},\n\t\t\t\t\t$rest: /** @type {Grammar['$rest']} */ ('jsx'),\n\t\t\t\t}),\n\t\t\t},\n\t\t});\n\n\t\tjsx.$tokenize = (code, grammar, Prism) => {\n\t\t\tconst tokens = Prism.tokenize(code, withoutTokenize(grammar));\n\t\t\twalkTokens(tokens);\n\t\t\treturn tokens;\n\t\t};\n\n\t\treturn jsx;\n\t},\n};\n\n/**\n * @typedef {import('../types.d.ts').Grammar} Grammar\n * @typedef {import('../types.d.ts').TokenStream} TokenStream\n * @typedef {import('../types.d.ts').GrammarToken} GrammarToken\n */\n"],"names":["stringifyToken","token","getTextContent","walkTokens","tokens","openedTags","i","length","isToken","notTagNorBrace","nestedTag","content","type","firstChild","tagName","pop","lastChild","push","openedBraces","plainText","next","splice","prev","Token","undefined","jsx","id","require","markup","javascript","grammar","extend","spread","re","source","flags","replace","RegExp","tag","pattern","inside","insertBefore","script","alias","$rest","$tokenize","code","Prism","tokenize","withoutTokenize"],"mappings":"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"}