{"version":3,"file":"xquery.js","sources":["../../src/languages/xquery.js"],"sourcesContent":["import { getTextContent, Token } from '../core/classes/token.js';\nimport { withoutTokenize } from '../util/language-util.js';\nimport markup from './markup.js';\n\n/**\n * @param {TokenStream} tokens\n */\nfunction walkTokens (tokens) {\n\tconst openedTags = [];\n\tfor (let i = 0; i < tokens.length; i++) {\n\t\tconst token = tokens[i];\n\t\tconst isToken = typeof token !== 'string';\n\t\tlet notTagNorBrace = false;\n\n\t\tif (isToken) {\n\t\t\tconst nestedTag = token.content[1];\n\t\t\tif (token.type === 'tag' && typeof nestedTag === 'object' && nestedTag.type === 'tag') {\n\t\t\t\t// We found a tag, now find its kind\n\n\t\t\t\tconst firstChild = token.content[0];\n\t\t\t\tif (typeof firstChild === 'object' && firstChild.content === '</') {\n\t\t\t\t\t// Closing tag\n\t\t\t\t\tif (\n\t\t\t\t\t\topenedTags.length > 0 &&\n\t\t\t\t\t\topenedTags[openedTags.length - 1].tagName === getTextContent(nestedTag)\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Pop matching opening tag\n\t\t\t\t\t\topenedTags.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst lastChild = token.content[token.content.length - 1];\n\t\t\t\t\tif (typeof lastChild === 'object' && lastChild.content === '/>') {\n\t\t\t\t\t\t// Autoclosed tag, ignore\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Opening tag\n\t\t\t\t\t\topenedTags.push({\n\t\t\t\t\t\t\ttagName: getTextContent(nestedTag),\n\t\t\t\t\t\t\topenedBraces: 0,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst next = tokens[i + 1];\n\t\t\t\tconst prev = tokens[i - 1];\n\t\t\t\tif (\n\t\t\t\t\topenedTags.length > 0 &&\n\t\t\t\t\ttoken.type === 'punctuation' &&\n\t\t\t\t\ttoken.content === '{' &&\n\t\t\t\t\t// Ignore `{{`\n\t\t\t\t\t(typeof next !== 'object' ||\n\t\t\t\t\t\tnext.type !== 'punctuation' ||\n\t\t\t\t\t\tnext.content !== '{') &&\n\t\t\t\t\t(typeof prev !== 'object' || prev.type !== 'plain-text' || prev.content !== '{')\n\t\t\t\t) {\n\t\t\t\t\t// Here we might have entered an XQuery expression inside a tag\n\t\t\t\t\topenedTags[openedTags.length - 1].openedBraces++;\n\t\t\t\t}\n\t\t\t\telse if (\n\t\t\t\t\topenedTags.length > 0 &&\n\t\t\t\t\topenedTags[openedTags.length - 1].openedBraces > 0 &&\n\t\t\t\t\ttoken.type === 'punctuation' &&\n\t\t\t\t\ttoken.content === '}'\n\t\t\t\t) {\n\t\t\t\t\t// Here we might have left an XQuery expression inside a tag\n\t\t\t\t\topenedTags[openedTags.length - 1].openedBraces--;\n\t\t\t\t}\n\t\t\t\telse if (token.type !== 'comment') {\n\t\t\t\t\tnotTagNorBrace = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (notTagNorBrace || !isToken) {\n\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n\t\t\t\t// Here we are inside a tag, and not inside an XQuery expression.\n\t\t\t\t// That's plain text: drop any tokens matched.\n\t\t\t\tlet plainText = getTextContent(token);\n\n\t\t\t\t// And merge text with adjacent text\n\t\t\t\tconst next = tokens[i + 1];\n\t\t\t\tif (next && (typeof next === 'string' || next.type === 'plain-text')) {\n\t\t\t\t\tplainText += getTextContent(next);\n\t\t\t\t\ttokens.splice(i + 1, 1);\n\t\t\t\t}\n\t\t\t\tconst prev = tokens[i - 1];\n\t\t\t\tif (prev && (typeof prev === 'string' || prev.type === 'plain-text')) {\n\t\t\t\t\tplainText = getTextContent(prev) + plainText;\n\t\t\t\t\ttokens.splice(i - 1, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t\t\tif (/^\\s+$/.test(plainText)) {\n\t\t\t\t\ttokens[i] = plainText;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttokens[i] = new Token('plain-text', plainText, undefined, plainText);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isToken && typeof token.content !== 'string') {\n\t\t\twalkTokens(token.content);\n\t\t}\n\t}\n}\n\n/** @type {import('../types.d.ts').LanguageProto<'xquery'>} */\nexport default {\n\tid: 'xquery',\n\tbase: markup,\n\tgrammar ({ base }) {\n\t\tconst tag = /** @type {GrammarToken} */ (base['tag']);\n\t\ttag.pattern =\n\t\t\t/<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/;\n\n\t\tconst attrValue = /** @type {GrammarToken} */ (\n\t\t\t/** @type {Grammar} */ (tag.inside)['attr-value']\n\t\t);\n\t\tattrValue.pattern =\n\t\t\t/=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/;\n\t\tconst attrValueInside = /** @type {Grammar} */ (attrValue.inside);\n\t\tattrValueInside['punctuation'] = /^=\"|\"$/;\n\t\tattrValueInside['expression'] = {\n\t\t\t// Allow for two levels of nesting\n\t\t\tpattern: /\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}/,\n\t\t\talias: 'language-xquery',\n\t\t\tinside: 'xquery',\n\t\t};\n\n\t\tbase.$tokenize = (code, grammar, Prism) => {\n\t\t\tconst tokens = Prism.tokenize(code, withoutTokenize(grammar));\n\t\t\twalkTokens(tokens);\n\t\t\treturn tokens;\n\t\t};\n\n\t\treturn {\n\t\t\t'xquery-comment': {\n\t\t\t\tpattern: /\\(:[\\s\\S]*?:\\)/,\n\t\t\t\tgreedy: true,\n\t\t\t\talias: 'comment',\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n\t\t\t\tgreedy: true,\n\t\t\t},\n\t\t\t'extension': {\n\t\t\t\tpattern: /\\(#.+?#\\)/,\n\t\t\t\talias: 'symbol',\n\t\t\t},\n\t\t\t'variable': /\\$[-\\w:]+/,\n\t\t\t'axis': {\n\t\t\t\tpattern:\n\t\t\t\t\t/(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'operator',\n\t\t\t},\n\t\t\t'keyword-operator': {\n\t\t\t\tpattern:\n\t\t\t\t\t/(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'operator',\n\t\t\t},\n\t\t\t'keyword': {\n\t\t\t\tpattern:\n\t\t\t\t\t/(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n\t\t\t\tlookbehind: true,\n\t\t\t},\n\t\t\t'function': /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n\t\t\t'xquery-element': {\n\t\t\t\tpattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'tag',\n\t\t\t},\n\t\t\t'xquery-attribute': {\n\t\t\t\tpattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'attr-name',\n\t\t\t},\n\t\t\t'builtin': {\n\t\t\t\tpattern:\n\t\t\t\t\t/(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n\t\t\t\tlookbehind: true,\n\t\t\t},\n\t\t\t'number': /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n\t\t\t'operator': [\n\t\t\t\t/[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/,\n\t\t\t\t{\n\t\t\t\t\tpattern: /(\\s)-(?=\\s)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t},\n\t\t\t],\n\t\t\t'punctuation': /[[\\](){},;:/]/,\n\t\t};\n\t},\n};\n\n/**\n * @typedef {import('../types.d.ts').TokenStream} TokenStream\n * @typedef {import('../types.d.ts').GrammarToken} GrammarToken\n * @typedef {import('../types.d.ts').Grammar} Grammar\n */\n"],"names":["walkTokens","tokens","openedTags","i","length","token","isToken","notTagNorBrace","nestedTag","content","type","firstChild","tagName","getTextContent","pop","lastChild","push","openedBraces","next","prev","plainText","splice","test","Token","undefined","xquery","id","base","markup","grammar","tag","pattern","attrValue","attrValueInside","alias","inside","$tokenize","code","Prism","tokenize","withoutTokenize","greedy","string","extension","variable","axis","lookbehind","keyword","function","builtin","number","operator","punctuation"],"mappings":"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"}