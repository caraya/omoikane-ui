{"version":3,"file":"zig.js","sources":["../../src/languages/zig.js"],"sourcesContent":["/** @type {import('../types.d.ts').LanguageProto<'zig'>} */\nexport default {\n\tid: 'zig',\n\tgrammar () {\n\t\t/**\n\t\t *\n\t\t * @param {string} str\n\t\t * @returns {function():string}\n\t\t */\n\t\tfunction literal (str) {\n\t\t\treturn function () {\n\t\t\t\treturn str;\n\t\t\t};\n\t\t}\n\n\t\tconst keyword =\n\t\t\t/\\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\b/;\n\n\t\tconst IDENTIFIER = '\\\\b(?!' + keyword.source + ')(?!\\\\d)\\\\w+\\\\b';\n\t\tconst ALIGN = /align\\s*\\((?:[^()]|\\([^()]*\\))*\\)/.source;\n\t\tconst PREFIX_TYPE_OP =\n\t\t\t/(?:\\?|\\bpromise->|(?:\\[[^[\\]]*\\]|\\*(?!\\*)|\\*\\*)(?:\\s*<ALIGN>|\\s*const\\b|\\s*volatile\\b|\\s*allowzero\\b)*)/.source.replace(\n\t\t\t\t/<ALIGN>/g,\n\t\t\t\tliteral(ALIGN)\n\t\t\t);\n\t\tconst SUFFIX_EXPR =\n\t\t\t/(?:\\bpromise\\b|(?:\\berror\\.)?<ID>(?:\\.<ID>)*(?!\\s+<ID>))/.source.replace(\n\t\t\t\t/<ID>/g,\n\t\t\t\tliteral(IDENTIFIER)\n\t\t\t);\n\t\tconst TYPE = '(?!\\\\s)(?:!?\\\\s*(?:' + PREFIX_TYPE_OP + '\\\\s*)*' + SUFFIX_EXPR + ')+';\n\n\t\t/*\n\t\t * A simplified grammar for Zig compile time type literals:\n\t\t *\n\t\t * TypeExpr = ( \"!\"? PREFIX_TYPE_OP* SUFFIX_EXPR )+\n\t\t *\n\t\t * SUFFIX_EXPR = ( \\b \"promise\" \\b | ( \\b \"error\" \".\" )? IDENTIFIER ( \".\" IDENTIFIER )* (?! \\s+ IDENTIFIER ) )\n\t\t *\n\t\t * PREFIX_TYPE_OP = \"?\"\n\t\t *                | \\b \"promise\" \"->\"\n\t\t *                | ( \"[\" [^\\[\\]]* \"]\" | \"*\" | \"**\" ) ( ALIGN | \"const\" \\b | \"volatile\" \\b | \"allowzero\" \\b )*\n\t\t *\n\t\t * ALIGN = \"align\" \"(\" ( [^()] | \"(\" [^()]* \")\" )* \")\"\n\t\t *\n\t\t * IDENTIFIER = \\b (?! KEYWORD ) [a-zA-Z_] \\w* \\b\n\t\t *\n\t\t */\n\n\t\treturn {\n\t\t\t'comment': [\n\t\t\t\t{\n\t\t\t\t\tpattern: /\\/\\/[/!].*/,\n\t\t\t\t\talias: 'doc-comment',\n\t\t\t\t},\n\t\t\t\t/\\/{2}.*/,\n\t\t\t],\n\t\t\t'string': [\n\t\t\t\t{\n\t\t\t\t\t// \"string\" and c\"string\"\n\t\t\t\t\tpattern: /(^|[^\\\\@])c?\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// multiline strings and c-strings\n\t\t\t\t\tpattern: /([\\r\\n])([ \\t]+c?\\\\{2}).*(?:(?:\\r\\n?|\\n)\\2.*)*/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t},\n\t\t\t],\n\t\t\t'char': {\n\t\t\t\t// characters 'a', '\\n', '\\xFF', '\\u{10FFFF}'\n\t\t\t\tpattern:\n\t\t\t\t\t/(^|[^\\\\])'(?:[^'\\\\\\r\\n]|[\\uD800-\\uDFFF]{2}|\\\\(?:.|x[a-fA-F\\d]{2}|u\\{[a-fA-F\\d]{1,6}\\}))'/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t},\n\t\t\t'builtin': /\\B@(?!\\d)\\w+(?=\\s*\\()/,\n\t\t\t'label': {\n\t\t\t\tpattern:\n\t\t\t\t\t/(\\b(?:break|continue)\\s*:\\s*)\\w+\\b|\\b(?!\\d)\\w+\\b(?=\\s*:\\s*(?:\\{|while\\b))/,\n\t\t\t\tlookbehind: true,\n\t\t\t},\n\t\t\t'class-name': [\n\t\t\t\t// const Foo = struct {};\n\t\t\t\t/\\b(?!\\d)\\w+(?=\\s*=\\s*(?:(?:extern|packed)\\s+)?(?:enum|struct|union)\\s*[({])/,\n\t\t\t\t{\n\t\t\t\t\t// const x: i32 = 9;\n\t\t\t\t\t// var x: Bar;\n\t\t\t\t\t// fn foo(x: bool, y: f32) void {}\n\t\t\t\t\tpattern: RegExp(\n\t\t\t\t\t\t/(:\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?[=;,)])|<TYPE>(?=\\s*(?:<ALIGN>\\s*)?\\{)/.source\n\t\t\t\t\t\t\t.replace(/<TYPE>/g, literal(TYPE))\n\t\t\t\t\t\t\t.replace(/<ALIGN>/g, literal(ALIGN))\n\t\t\t\t\t),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: 'zig',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// extern fn foo(x: f64) f64; (optional alignment)\n\t\t\t\t\tpattern: RegExp(\n\t\t\t\t\t\t/(\\)\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?;)/.source\n\t\t\t\t\t\t\t.replace(/<TYPE>/g, literal(TYPE))\n\t\t\t\t\t\t\t.replace(/<ALIGN>/g, literal(ALIGN))\n\t\t\t\t\t),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: 'zig',\n\t\t\t\t},\n\t\t\t],\n\t\t\t'builtin-type': {\n\t\t\t\tpattern:\n\t\t\t\t\t/\\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\\b/,\n\t\t\t\talias: 'keyword',\n\t\t\t},\n\t\t\t'keyword': keyword,\n\t\t\t'function': /\\b(?!\\d)\\w+(?=\\s*\\()/,\n\t\t\t'number':\n\t\t\t\t/\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\d]+(?:\\.[a-fA-F\\d]*)?(?:[pP][+-]?[a-fA-F\\d]+)?|\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\b/,\n\t\t\t'boolean': /\\b(?:false|true)\\b/,\n\t\t\t'operator':\n\t\t\t\t/\\.[*?]|\\.{2,3}|[-=]>|\\*\\*|\\+\\+|\\|\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,\n\t\t\t'punctuation': /[.:,;(){}[\\]]/,\n\t\t};\n\t},\n};\n"],"names":["zig","id","grammar","literal","str","keyword","IDENTIFIER","source","ALIGN","TYPE","replace","comment","pattern","alias","string","lookbehind","greedy","char","builtin","label","RegExp","inside","function","number","boolean","operator","punctuation"],"mappings":"AACA,IAAeA,EAAA,CACdC,GAAI,MACJ,OAAAC,GAMC,SAASC,EAASC,GACjB,MAAO,IACCA,CAEX,CAEE,MAAMC,EACL,iXAEKC,EAAa,SAAWD,EAAQE,OAAS,kBACzCC,EAAQ,yCAWRC,EAAO,sBATZ,0HAAiHC,QAChH,WACAP,EAAQK,IAO4C,SAJrD,iEAAkEE,QACjE,QACAP,EAAQG,IAEqE,KAmB/E,MAAO,CACNK,QAAW,CACV,CACCC,QAAS,aACTC,MAAO,eAER,WAEDC,OAAU,CACT,CAECF,QAAS,oCACTG,YAAY,EACZC,QAAQ,GAET,CAECJ,QAAS,iDACTG,YAAY,EACZC,QAAQ,IAGVC,KAAQ,CAEPL,QACC,2FACDG,YAAY,EACZC,QAAQ,GAETE,QAAW,wBACXC,MAAS,CACRP,QACC,4EACDG,YAAY,GAEb,aAAc,CAEb,8EACA,CAICH,QAASQ,OACR,gFACEV,QAAQ,UAAWP,EAAQM,IAC3BC,QAAQ,WAAYP,EAAQK,KAE/BO,YAAY,EACZM,OAAQ,OAET,CAECT,QAASQ,OACR,2CACEV,QAAQ,UAAWP,EAAQM,IAC3BC,QAAQ,WAAYP,EAAQK,KAE/BO,YAAY,EACZM,OAAQ,QAGV,eAAgB,CACfT,QACC,oKACDC,MAAO,WAERR,QAAWA,EACXiB,SAAY,uBACZC,OACC,mHACDC,QAAW,qBACXC,SACC,6EACDC,YAAe,gBAEhB"}