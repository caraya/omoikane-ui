{"version":3,"file":"insert-CpDsPTVw.js","sources":["../src/util/objects.js","../src/util/insert.js"],"sourcesContent":["import { toArray } from './iterables.js';\n\n/**\n * @template {Record<string, any>} T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K} key\n * @param {() => T[K]} getter\n * @param {any} [waitFor]\n * @returns {Promise<void>}\n */\nexport async function defineLazyProperty (obj, key, getter, waitFor) {\n\tif (waitFor) {\n\t\tawait waitFor;\n\t}\n\n\tObject.defineProperty(obj, key, {\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t\tget () {\n\t\t\tconst value = getter.call(this);\n\t\t\t// Replace the getter with a writable property\n\t\t\tdefineSimpleProperty(this, key, value);\n\t\t\treturn value;\n\t\t},\n\t\tset (value) {\n\t\t\tdefineSimpleProperty(this, key, value);\n\t\t},\n\t});\n}\n\n/**\n * @template {Record<string, any>} T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K} key\n * @param {T[K]} value\n * @returns {void}\n */\nexport function defineSimpleProperty (obj, key, value) {\n\tObject.defineProperty(obj, key, {\n\t\tvalue,\n\t\twritable: true,\n\t\tenumerable: true,\n\t\tconfigurable: false,\n\t});\n}\n\n/**\n *\n * @param {any} obj\n * @param {string} type\n * @returns {boolean}\n */\nexport function isObject (obj, type) {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn false;\n\t}\n\n\tconst proto = Object.getPrototypeOf(obj);\n\treturn proto.constructor?.name === type;\n}\n\n/**\n * @param {any} obj\n * @returns {boolean}\n */\nexport function isPlainObject (obj) {\n\treturn isObject(obj, 'Object');\n}\n\n/**\n * @typedef {object} MergeOptions\n * @property {any[]} [emptyValues]\n * @property {string[]} [containers]\n * @property {(value: any, key?: Property, parent?: any) => boolean} [isContainer]\n * @property {boolean} [mergeArrays]\n */\n\n/** @typedef {string | number | symbol} Property */\n\n/**\n *\n * @param {any} target\n * @param {any} source\n * @param {MergeOptions} [options={}]\n * @returns\n */\nexport function deepMerge (target, source, options = {}) {\n\tconst {\n\t\temptyValues = [undefined],\n\t\tcontainers = ['Object', 'EventTarget'],\n\t\tisContainer = value => containers.some(type => isObject(value, type)),\n\t\tmergeArrays = false,\n\t} = options;\n\n\tif (mergeArrays && (Array.isArray(target) || Array.isArray(source))) {\n\t\ttarget = toArray(target);\n\t\tsource = toArray(source);\n\t\treturn target.concat(source);\n\t}\n\n\tif (isContainer(target) && isContainer(source)) {\n\t\tfor (const key in source) {\n\t\t\ttarget[key] = deepMerge(target[key], source[key], options);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\tif (emptyValues.includes(target)) {\n\t\treturn source;\n\t}\n\n\treturn source ?? target;\n}\n\n/**\n * @typedef {object} CloneOptions\n *\n * Used internally to store clones of objects,\n * both for performance but mainly to avoid getting tripped up in circular references\n * @property {WeakMap<any, any>} [_clones]\n */\n\n/**\n * @param {any} obj\n * @param {CloneOptions} options\n */\nexport function deepClone (obj, options = {}) {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\n\toptions._clones ??= new WeakMap();\n\tconst { _clones } = options;\n\n\tif (_clones.has(obj)) {\n\t\treturn _clones.get(obj);\n\t}\n\n\tlet ret = obj;\n\n\tif (Array.isArray(obj)) {\n\t\tret = [];\n\t\t_clones.set(obj, ret);\n\n\t\tfor (const item of obj) {\n\t\t\tret.push(deepClone(item, options));\n\t\t}\n\t}\n\telse if (isPlainObject(obj)) {\n\t\tret = { ...obj };\n\t\t_clones.set(obj, ret);\n\n\t\tfor (const key in obj) {\n\t\t\tret[key] = deepClone(obj[key], options);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/**\n * Like Object.assign() but preserves accessors.\n *\n * @param {Record<string, any>} target\n * @param {Record<string, any>[]} sources\n */\nexport function betterAssign (target, ...sources) {\n\tfor (const source of sources) {\n\t\tconst descriptors = Object.getOwnPropertyDescriptors(source);\n\t\tfor (const key in descriptors) {\n\t\t\tif (Object.hasOwn(target, key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst descriptor = descriptors[key];\n\t\t\tObject.defineProperty(target, key, descriptor);\n\t\t}\n\t}\n\n\treturn target;\n}\n","import { betterAssign } from './objects.js';\n\n/**\n * Inserts tokens _before_ another token in the given grammar.\n *\n * ## Usage\n *\n * This helper method makes it easy to modify existing grammars. For example, the CSS language definition\n * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n * this:\n *\n * ```js\n * markup.style = {\n *     // token\n * };\n * ```\n *\n * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n * before existing tokens. For the CSS example above, you would use it like this:\n *\n * ```js\n * insertBefore(markup, 'cdata', {\n *     'style': {\n *         // token\n *     }\n * });\n * ```\n *\n * @param {Grammar} grammar The grammar to be modified.\n * @param {string} beforeKey The key to insert before.\n * @param {GrammarTokens} tokens An object containing the key-value pairs to be inserted.\n */\nexport function insertBefore (grammar, beforeKey, tokens) {\n\tinsert(grammar, beforeKey, tokens, 'before');\n}\n\n/**\n *\n * @param {Grammar} grammar\n * @param {string} afterKey\n * @param {GrammarTokens} tokens\n */\nexport function insertAfter (grammar, afterKey, tokens) {\n\tinsert(grammar, afterKey, tokens);\n}\n\n/**\n *\n * @param {Grammar} grammar\n * @param {string} atKey\n * @param {GrammarTokens} insert\n * @param {'before' | 'after'} [position='after']\n */\nexport function insert (grammar, atKey, insert, position = 'after') {\n\tif (!(atKey in grammar)) {\n\t\t// TODO support deep keys\n\t\tthrow new Error(`\"${atKey}\" has to be a key of grammar.`);\n\t}\n\n\tconst descriptors = Object.getOwnPropertyDescriptors(grammar);\n\n\t// delete all keys in `grammar`\n\tfor (const key in descriptors) {\n\t\tif (Object.hasOwn(descriptors, key)) {\n\t\t\tdelete grammar[key];\n\t\t}\n\t}\n\n\t// insert keys again\n\tfor (const key in descriptors) {\n\t\tif (position === 'before' && key === atKey) {\n\t\t\tbetterAssign(grammar, insert);\n\t\t}\n\n\t\t// Do not insert tokens which also occur in `insert`. See #1525\n\t\tif (!Object.hasOwn(insert, key)) {\n\t\t\tObject.defineProperty(grammar, key, descriptors[key]);\n\t\t}\n\n\t\tif (position === 'after' && key === atKey) {\n\t\t\tbetterAssign(grammar, insert);\n\t\t}\n\t}\n}\n\n/**\n * @typedef {import('../types.d.ts').Grammar} Grammar\n * @typedef {import('../types.d.ts').GrammarToken} GrammarToken\n * @typedef {import('../types.d.ts').GrammarTokens} GrammarTokens\n */\n"],"names":["async","defineLazyProperty","obj","key","getter","waitFor","Object","defineProperty","enumerable","configurable","get","value","call","this","defineSimpleProperty","set","writable","isObject","type","proto","getPrototypeOf","constructor","name","deepMerge","target","source","options","emptyValues","undefined","containers","isContainer","some","mergeArrays","Array","isArray","toArray","concat","includes","deepClone","_clones","WeakMap","has","ret","item","push","isPlainObject","betterAssign","sources","descriptors","getOwnPropertyDescriptors","hasOwn","descriptor","insertBefore","grammar","beforeKey","tokens","insert","insertAfter","afterKey","atKey","position","Error"],"mappings":"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"}