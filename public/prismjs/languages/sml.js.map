{"version":3,"file":"sml.js","sources":["../../src/languages/sml.js"],"sourcesContent":["/** @type {import('../types.d.ts').LanguageProto<'sml'>} */\nexport default {\n\tid: 'sml',\n\talias: 'smlnj',\n\tgrammar () {\n\t\t// https://smlfamily.github.io/sml97-defn.pdf\n\t\t// https://people.mpi-sws.org/~rossberg/sml.html\n\n\t\tconst keywords =\n\t\t\t/\\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\\b/i;\n\n\t\treturn {\n\t\t\t// allow one level of nesting\n\t\t\t'comment': /\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*)|\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*))*\\*\\))*\\*\\)/,\n\t\t\t'string': {\n\t\t\t\tpattern: /#?\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t\t\t\tgreedy: true,\n\t\t\t},\n\n\t\t\t'class-name': [\n\t\t\t\t{\n\t\t\t\t\t// This is only an approximation since the real grammar is context-free\n\t\t\t\t\t//\n\t\t\t\t\t// Why the main loop so complex?\n\t\t\t\t\t// The main loop is approximately the same as /(?:\\s*(?:[*,]|->)\\s*<TERMINAL>)*/ which is, obviously, a lot\n\t\t\t\t\t// simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be\n\t\t\t\t\t// followed by a long identifier.\n\t\t\t\t\tpattern: RegExp(\n\t\t\t\t\t\t/((?:^|[^:]):\\s*)<TERMINAL>(?:\\s*(?:(?:\\*|->)\\s*<TERMINAL>|,\\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\\s+<LONG-ID>)))*/.source\n\t\t\t\t\t\t\t.replace(/<NOT-LAST>/g, () => /\\s*(?:[*,]|->)/.source)\n\t\t\t\t\t\t\t.replace(\n\t\t\t\t\t\t\t\t/<TERMINAL>/g,\n\t\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\t\t/(?:'[\\w']*|<LONG-ID>|\\((?:[^()]|\\([^()]*\\))*\\)|\\{(?:[^{}]|\\{[^{}]*\\})*\\})(?:\\s+<LONG-ID>)*/\n\t\t\t\t\t\t\t\t\t\t.source\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.replace(/<LONG-ID>/g, () => /(?!<KEYWORD>)[a-z\\d_][\\w'.]*/.source)\n\t\t\t\t\t\t\t.replace(/<KEYWORD>/g, () => keywords.source),\n\t\t\t\t\t\t'i'\n\t\t\t\t\t),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\tinside: 'sml',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpattern:\n\t\t\t\t\t\t/((?:^|[^\\w'])(?:datatype|exception|functor|signature|structure|type)\\s+)[a-z_][\\w'.]*/i,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t},\n\t\t\t],\n\t\t\t'function': {\n\t\t\t\tpattern: /((?:^|[^\\w'])fun\\s+)[a-z_][\\w'.]*/i,\n\t\t\t\tlookbehind: true,\n\t\t\t},\n\n\t\t\t'keyword': keywords,\n\t\t\t'variable': {\n\t\t\t\tpattern: /(^|[^\\w'])'[\\w']*/,\n\t\t\t\tlookbehind: true,\n\t\t\t},\n\n\t\t\t'number': /~?\\b(?:\\d+(?:\\.\\d+)?(?:e~?\\d+)?|0x[\\da-f]+)\\b/i,\n\t\t\t'word': {\n\t\t\t\tpattern: /\\b0w(?:\\d+|x[\\da-f]+)\\b/i,\n\t\t\t\talias: 'constant',\n\t\t\t},\n\n\t\t\t'boolean': /\\b(?:false|true)\\b/i,\n\t\t\t'operator': /\\.\\.\\.|:[>=:]|=>?|->|[<>]=?|[!+\\-*/^#|@~]/,\n\t\t\t'punctuation': /[(){}\\[\\].:,;]/,\n\t\t};\n\t},\n};\n"],"names":["sml","id","alias","grammar","keywords","comment","string","pattern","greedy","RegExp","replace","source","lookbehind","inside","function","keyword","variable","number","word","boolean","operator","punctuation"],"mappings":"AACA,IAAeA,EAAA,CACdC,GAAI,MACJC,MAAO,QACP,OAAAC,GAIC,MAAMC,EACL,0PAED,MAAO,CAENC,QAAW,4EACXC,OAAU,CACTC,QAAS,sBACTC,QAAQ,GAGT,aAAc,CACb,CAOCD,QAASE,OACR,iIACEC,QAAQ,eAAe,IAAM,oBAC7BA,QACA,eACA,IACC,yGAGDA,QAAQ,cAAc,IAAM,mCAC5BA,QAAQ,cAAc,IAAMN,EAASO,SACvC,KAEDC,YAAY,EACZJ,QAAQ,EACRK,OAAQ,OAET,CACCN,QACC,yFACDK,YAAY,IAGdE,SAAY,CACXP,QAAS,qCACTK,YAAY,GAGbG,QAAWX,EACXY,SAAY,CACXT,QAAS,oBACTK,YAAY,GAGbK,OAAU,iDACVC,KAAQ,CACPX,QAAS,2BACTL,MAAO,YAGRiB,QAAW,sBACXC,SAAY,4CACZC,YAAe,iBAEhB"}