{"version":3,"file":"graphql.js","sources":["../../src/languages/graphql.js"],"sourcesContent":["import { withoutTokenize } from '../util/language-util.js';\n\n/** @type {import('../types.d.ts').LanguageProto<'graphql'>} */\nexport default {\n\tid: 'graphql',\n\tgrammar: {\n\t\t'comment': /#.*/,\n\t\t'description': {\n\t\t\tpattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n\t\t\tgreedy: true,\n\t\t\talias: 'string',\n\t\t\tinside: {\n\t\t\t\t'language-markdown': {\n\t\t\t\t\tpattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: 'markdown',\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'string': {\n\t\t\tpattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n\t\t\tgreedy: true,\n\t\t},\n\t\t'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n\t\t'boolean': /\\b(?:false|true)\\b/,\n\t\t'variable': /\\$[a-z_]\\w*/i,\n\t\t'directive': {\n\t\t\tpattern: /@[a-z_]\\w*/i,\n\t\t\talias: 'function',\n\t\t},\n\t\t'attr-name': {\n\t\t\tpattern: /\\b[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n\t\t\tgreedy: true,\n\t\t},\n\t\t'atom-input': {\n\t\t\tpattern: /\\b[A-Z]\\w*Input\\b/,\n\t\t\talias: 'class-name',\n\t\t},\n\t\t'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n\t\t'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n\t\t'class-name': {\n\t\t\tpattern:\n\t\t\t\t/(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n\t\t\tlookbehind: true,\n\t\t},\n\t\t'fragment': {\n\t\t\tpattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'function',\n\t\t},\n\t\t'definition-mutation': {\n\t\t\tpattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'function',\n\t\t},\n\t\t'definition-query': {\n\t\t\tpattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'function',\n\t\t},\n\t\t'keyword':\n\t\t\t/\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n\t\t'operator': /[!=|&]|\\.{3}/,\n\t\t'property-query': /\\w+(?=\\s*\\()/,\n\t\t'object': /\\w+(?=\\s*\\{)/,\n\t\t'punctuation': /[!(){}\\[\\]:=,]/,\n\t\t'property': /\\w+/,\n\t\t/** @type {Grammar['$tokenize']} */\n\t\t$tokenize (code, grammar, Prism) {\n\t\t\tconst tokens = Prism.tokenize(code, withoutTokenize(grammar));\n\n\t\t\t/**\n\t\t\t * @param {Token | string} token\n\t\t\t * @returns {token is Token}\n\t\t\t */\n\t\t\tfunction isToken (token) {\n\t\t\t\treturn typeof token !== 'string';\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * get the graphql token stream that we want to customize\n\t\t\t */\n\t\t\tconst validTokens = tokens\n\t\t\t\t.filter(isToken)\n\t\t\t\t.filter(token => token.type !== 'comment' && token.type !== 'scalar');\n\n\t\t\tlet currentIndex = 0;\n\n\t\t\t/**\n\t\t\t * Returns whether the token relative to the current index has the given type.\n\t\t\t *\n\t\t\t * @param {number} [offset=0]\n\t\t\t * @returns {Token}\n\t\t\t */\n\t\t\tfunction getToken (offset = 0) {\n\t\t\t\treturn validTokens[currentIndex + offset];\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Returns whether the token relative to the current index has the given type.\n\t\t\t *\n\t\t\t * @param {string[]} types\n\t\t\t * @param {number} [offset=0]\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tfunction isTokenType (types, offset = 0) {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst token = getToken(i + offset);\n\t\t\t\t\tif (!token || token.type !== types[i]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Returns the index of the closing bracket to an opening bracket.\n\t\t\t *\n\t\t\t * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n\t\t\t *\n\t\t\t * If no closing bracket could be found, `-1` will be returned.\n\t\t\t *\n\t\t\t * @param {RegExp} open\n\t\t\t * @param {RegExp} close\n\t\t\t * @returns {number}\n\t\t\t */\n\t\t\tfunction findClosingBracket (open, close) {\n\t\t\t\tlet stackHeight = 1;\n\n\t\t\t\tfor (let i = currentIndex; i < validTokens.length; i++) {\n\t\t\t\t\tconst token = validTokens[i];\n\t\t\t\t\tconst content = token.content;\n\n\t\t\t\t\tif (token.type === 'punctuation' && typeof content === 'string') {\n\t\t\t\t\t\tif (open.test(content)) {\n\t\t\t\t\t\t\tstackHeight++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (close.test(content)) {\n\t\t\t\t\t\t\tstackHeight--;\n\n\t\t\t\t\t\t\tif (stackHeight === 0) {\n\t\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tfor (; currentIndex < validTokens.length; ) {\n\t\t\t\tconst startToken = validTokens[currentIndex++];\n\n\t\t\t\t// add special aliases for mutation tokens\n\t\t\t\tif (startToken.type === 'keyword' && startToken.content === 'mutation') {\n\t\t\t\t\t// any array of the names of all input variables (if any)\n\t\t\t\t\tconst inputVariables = [];\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tisTokenType(['definition-mutation', 'punctuation']) &&\n\t\t\t\t\t\tgetToken(1).content === '('\n\t\t\t\t\t) {\n\t\t\t\t\t\t// definition\n\n\t\t\t\t\t\tcurrentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n\t\t\t\t\t\tconst definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\t\t\t\t\t\tif (definitionEnd === -1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find all input variables\n\t\t\t\t\t\tfor (; currentIndex < definitionEnd; currentIndex++) {\n\t\t\t\t\t\t\tconst t = getToken(0);\n\t\t\t\t\t\t\tif (t.type === 'variable') {\n\t\t\t\t\t\t\t\tt.addAlias('variable-input');\n\t\t\t\t\t\t\t\tinputVariables.push(t.content);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentIndex = definitionEnd + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tisTokenType(['punctuation', 'property-query']) &&\n\t\t\t\t\t\tgetToken(0).content === '{'\n\t\t\t\t\t) {\n\t\t\t\t\t\tcurrentIndex++; // skip opening bracket\n\n\t\t\t\t\t\tgetToken(0).addAlias('property-mutation');\n\n\t\t\t\t\t\tif (inputVariables.length > 0) {\n\t\t\t\t\t\t\tconst mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\t\t\t\t\t\t\tif (mutationEnd === -1) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// give references to input variables a special alias\n\t\t\t\t\t\t\tfor (let i = currentIndex; i < mutationEnd; i++) {\n\t\t\t\t\t\t\t\tconst varToken = validTokens[i];\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tvarToken.type === 'variable' &&\n\t\t\t\t\t\t\t\t\tinputVariables.includes(varToken.content)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tvarToken.addAlias('variable-input');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn tokens;\n\t\t},\n\t},\n};\n\n/**\n * @typedef {import('../core.js').Token} Token\n * @typedef {import('../types.d.ts').Grammar} Grammar\n */\n"],"names":["graphql","id","grammar","comment","description","pattern","greedy","alias","inside","lookbehind","string","number","boolean","variable","directive","scalar","constant","fragment","keyword","operator","object","punctuation","property","$tokenize","code","Prism","tokens","tokenize","withoutTokenize","validTokens","filter","token","type","currentIndex","getToken","offset","isTokenType","types","i","length","findClosingBracket","open","close","stackHeight","content","test","startToken","inputVariables","definitionEnd","t","addAlias","push","mutationEnd","varToken","includes"],"mappings":"oDAGA,IAAeA,EAAA,CACdC,GAAI,UACLC,QAAA,KAAA,CAAAC,QAAA,MAAAC,YAAA,CAAAC,QAAA,mEAAAC,QAAA,EAAAC,MAAA,SAAAC,OAAA,CAAA,oBAAA,CAAAH,QAAA,kCAAAI,YAAA,EAAAD,OAAA,cAAAE,OAAA,CAAAL,QAAA,iDAAAC,QAAA,GAAAK,OAAA,2CAAAC,QAAA,qBAAAC,SAAA,eAAAC,UAAA,CAAAT,QAAA,cAAAE,MAAA,YAAA,YAAA,CAAAF,QAAA,iEAAAC,QAAA,GAAA,aAAA,CAAAD,QAAA,oBAAAE,MAAA,cAAAQ,OAAA,sCAAAC,SAAA,qBAAA,aAAA,CAAAX,QAAA,kFAAAI,YAAA,GAAAQ,SAAA,CAAAZ,QAAA,+CAAAI,YAAA,EAAAF,MAAA,YAAA,sBAAA,CAAAF,QAAA,8BAAAI,YAAA,EAAAF,MAAA,YAAA,mBAAA,CAAAF,QAAA,2BAAAI,YAAA,EAAAF,MAAA,YAAAW,QAAA,uIAAAC,SAAA,eAAA,iBAAA,eAAAC,OAAA,eAAAC,YAAA,iBAAAC,SAAA,MAAA,SAAAC,CAAAC,EAAAtB,EAAAuB,GAAA,MAAAC,EAAAD,EAAAE,SAAAH,EAAAI,EAAA1B,IAAA2B,EAAAH,EAAAI,QAAAC,GAAA,iBAAAA,IAAAD,QAAAC,GAAA,YAAAA,EAAAC,MAAA,WAAAD,EAAAC,OAAA,IAAAC,EAAA,EAAA,SAAAC,EAAAC,EAAA,GAAA,OAAAN,EAAAI,EAAAE,EAAA,CAAA,SAAAC,EAAAC,EAAAF,EAAA,GAAA,IAAA,IAAAG,EAAA,EAAAA,EAAAD,EAAAE,OAAAD,IAAA,CAAA,MAAAP,EAAAG,EAAAI,EAAAH,GAAA,IAAAJ,GAAAA,EAAAC,OAAAK,EAAAC,GAAA,OAAA,CAAA,CAAA,OAAA,CAAA,CAAA,SAAAE,EAAAC,EAAAC,GAAA,IAAAC,EAAA,EAAA,IAAA,IAAAL,EAAAL,EAAAK,EAAAT,EAAAU,OAAAD,IAAA,CAAA,MAAAP,EAAAF,EAAAS,GAAAM,EAAAb,EAAAa,QAAA,GAAA,gBAAAb,EAAAC,MAAA,iBAAAY,EAAA,GAAAH,EAAAI,KAAAD,GAAAD,SAAA,GAAAD,EAAAG,KAAAD,KAAAD,IAAA,IAAAA,GAAA,OAAAL,CAAA,CAAA,OAAA,CAAA,CAAA,KAAAL,EAAAJ,EAAAU,QAAA,CAAA,MAAAO,EAAAjB,EAAAI,KAAA,GAAA,YAAAa,EAAAd,MAAA,aAAAc,EAAAF,QAAA,CAAA,MAAAG,EAAA,GAAA,GAAAX,EAAA,CAAA,sBAAA,iBAAA,MAAAF,EAAA,GAAAU,QAAA,CAAAX,GAAA,EAAA,MAAAe,EAAAR,EAAA,OAAA,QAAA,IAAA,IAAAQ,EAAA,SAAA,KAAAf,EAAAe,EAAAf,IAAA,CAAA,MAAAgB,EAAAf,EAAA,GAAA,aAAAe,EAAAjB,OAAAiB,EAAAC,SAAA,kBAAAH,EAAAI,KAAAF,EAAAL,SAAA,CAAAX,EAAAe,EAAA,CAAA,CAAA,GAAAZ,EAAA,CAAA,cAAA,oBAAA,MAAAF,EAAA,GAAAU,UAAAX,IAAAC,EAAA,GAAAgB,SAAA,qBAAAH,EAAAR,OAAA,GAAA,CAAA,MAAAa,EAAAZ,EAAA,OAAA,QAAA,IAAA,IAAAY,EAAA,SAAA,IAAA,IAAAd,EAAAL,EAAAK,EAAAc,EAAAd,IAAA,CAAA,MAAAe,EAAAxB,EAAAS,GAAA,aAAAe,EAAArB,MAAAe,EAAAO,SAAAD,EAAAT,UAAAS,EAAAH,SAAA,iBAAA,CAAA,CAAA,CAAA,CAAA,OAAAxB,CAAA"}