{"version":3,"file":"csharp.js","sources":["../../src/languages/csharp.js"],"sourcesContent":["import clike from './clike.js';\n\n/**\n * Replaces all placeholders \"<<n>>\" of given pattern with the n-th replacement (zero based).\n *\n * Note: This is a simple text based replacement. Be careful when using backreferences!\n *\n * @param pattern the given pattern.\n * @param replacements a list of replacement which can be inserted into the given pattern.\n * @returns the pattern with all placeholders replaced with their corresponding replacements.\n * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source\n */\nfunction replace (pattern, replacements) {\n\treturn pattern.replace(/<<(\\d+)>>/g, (m, index) => {\n\t\treturn '(?:' + replacements[+index] + ')';\n\t});\n}\nfunction re (pattern, replacements, flags) {\n\treturn RegExp(replace(pattern, replacements), flags || '');\n}\n\n/**\n * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\n */\nfunction nested (pattern, depthLog2) {\n\tfor (let i = 0; i < depthLog2; i++) {\n\t\tpattern = pattern.replace(/<<self>>/g, () => '(?:' + pattern + ')');\n\t}\n\treturn pattern.replace(/<<self>>/g, '[^\\\\s\\\\S]');\n}\n\n/** @type {import('../types.d.ts').LanguageProto<'csharp'>} */\nexport default {\n\tid: 'csharp',\n\tbase: clike,\n\toptional: 'xml-doc',\n\talias: ['cs', 'dotnet'],\n\tgrammar ({ getOptionalLanguage }) {\n\t\t// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/\n\t\tconst keywordKinds = {\n\t\t\t// keywords which represent a return or variable type\n\t\t\ttype: 'bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void',\n\t\t\t// keywords which are used to declare a type\n\t\t\ttypeDeclaration: 'class enum interface record struct',\n\t\t\t// contextual keywords\n\t\t\t// (\"var\" and \"dynamic\" are missing because they are used like types)\n\t\t\tcontextual:\n\t\t\t\t'add alias and ascending async await by descending from(?=\\\\s*(?:\\\\w|$)) get global group into init(?=\\\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\\\s*{)',\n\t\t\t// all other keywords\n\t\t\tother: 'abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield',\n\t\t};\n\n\t\t// keywords\n\t\tfunction keywordsToPattern (words) {\n\t\t\treturn '\\\\b(?:' + words.trim().replace(/ /g, '|') + ')\\\\b';\n\t\t}\n\t\tconst typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);\n\t\tconst keywords = RegExp(\n\t\t\tkeywordsToPattern(\n\t\t\t\tkeywordKinds.type +\n\t\t\t\t\t' ' +\n\t\t\t\t\tkeywordKinds.typeDeclaration +\n\t\t\t\t\t' ' +\n\t\t\t\t\tkeywordKinds.contextual +\n\t\t\t\t\t' ' +\n\t\t\t\t\tkeywordKinds.other\n\t\t\t)\n\t\t);\n\t\tconst nonTypeKeywords = keywordsToPattern(\n\t\t\tkeywordKinds.typeDeclaration + ' ' + keywordKinds.contextual + ' ' + keywordKinds.other\n\t\t);\n\t\tconst nonContextualKeywords = keywordsToPattern(\n\t\t\tkeywordKinds.type + ' ' + keywordKinds.typeDeclaration + ' ' + keywordKinds.other\n\t\t);\n\n\t\t// types\n\t\tconst generic = nested(/<(?:[^<>;=+\\-*/%&|^]|<<self>>)*>/.source, 2); // the idea behind the other forbidden characters is to prevent false positives. Same for tupleElement.\n\t\tconst nestedRound = nested(/\\((?:[^()]|<<self>>)*\\)/.source, 2);\n\t\tconst name = /@?\\b[A-Za-z_]\\w*\\b/.source;\n\t\tconst genericName = replace(/<<0>>(?:\\s*<<1>>)?/.source, [name, generic]);\n\t\tconst identifier = replace(/(?!<<0>>)<<1>>(?:\\s*\\.\\s*<<1>>)*/.source, [\n\t\t\tnonTypeKeywords,\n\t\t\tgenericName,\n\t\t]);\n\t\tconst array = /\\[\\s*(?:,\\s*)*\\]/.source;\n\t\tconst typeExpressionWithoutTuple = replace(\n\t\t\t/<<0>>(?:\\s*(?:\\?\\s*)?<<1>>)*(?:\\s*\\?)?/.source,\n\t\t\t[identifier, array]\n\t\t);\n\t\tconst tupleElement = replace(/[^,()<>[\\];=+\\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [\n\t\t\tgeneric,\n\t\t\tnestedRound,\n\t\t\tarray,\n\t\t]);\n\t\tconst tuple = replace(/\\(<<0>>+(?:,<<0>>+)+\\)/.source, [tupleElement]);\n\t\tconst typeExpression = replace(/(?:<<0>>|<<1>>)(?:\\s*(?:\\?\\s*)?<<2>>)*(?:\\s*\\?)?/.source, [\n\t\t\ttuple,\n\t\t\tidentifier,\n\t\t\tarray,\n\t\t]);\n\n\t\tconst typeInside = {\n\t\t\t'keyword': keywords,\n\t\t\t'punctuation': /[<>()?,.:[\\]]/,\n\t\t};\n\n\t\t// strings & characters\n\t\t// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#character-literals\n\t\t// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#string-literals\n\t\tconst character = /'(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'/.source; // simplified pattern\n\t\tconst regularString = /\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/.source;\n\t\tconst verbatimString = /@\"(?:\"\"|\\\\[\\s\\S]|[^\\\\\"])*\"(?!\")/.source;\n\n\t\t// attributes\n\t\tconst regularStringOrCharacter = regularString + '|' + character;\n\t\tconst regularStringCharacterOrComment = replace(\n\t\t\t/\\/(?![*/])|\\/\\/[^\\r\\n]*[\\r\\n]|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>/.source,\n\t\t\t[regularStringOrCharacter]\n\t\t);\n\t\tconst roundExpression = nested(\n\t\t\treplace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [regularStringCharacterOrComment]),\n\t\t\t2\n\t\t);\n\n\t\t// https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/#attribute-targets\n\t\tconst attrTarget = /\\b(?:assembly|event|field|method|module|param|property|return|type)\\b/\n\t\t\t.source;\n\t\tconst attr = replace(/<<0>>(?:\\s*\\(<<1>>*\\))?/.source, [identifier, roundExpression]);\n\n\t\t// string interpolation\n\t\tconst formatString = /:[^}\\r\\n]+/.source;\n\t\t// multi line\n\t\tconst mInterpolationRound = nested(\n\t\t\treplace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [regularStringCharacterOrComment]),\n\t\t\t2\n\t\t);\n\t\tconst mInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [\n\t\t\tmInterpolationRound,\n\t\t\tformatString,\n\t\t]);\n\t\t// single line\n\t\tconst sInterpolationRound = nested(\n\t\t\treplace(/[^\"'/()]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>|\\(<<self>>*\\)/.source, [\n\t\t\t\tregularStringOrCharacter,\n\t\t\t]),\n\t\t\t2\n\t\t);\n\t\tconst sInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [\n\t\t\tsInterpolationRound,\n\t\t\tformatString,\n\t\t]);\n\n\t\tfunction createInterpolationInside (interpolation, interpolationRound) {\n\t\t\treturn {\n\t\t\t\t'interpolation': {\n\t\t\t\t\tpattern: re(/((?:^|[^{])(?:\\{\\{)*)<<0>>/.source, [interpolation]),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'format-string': {\n\t\t\t\t\t\t\tpattern: re(/(^\\{(?:(?![}:])<<0>>)*)<<1>>(?=\\}$)/.source, [\n\t\t\t\t\t\t\t\tinterpolationRound,\n\t\t\t\t\t\t\t\tformatString,\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t\t'punctuation': /^:/,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': /^\\{|\\}$/,\n\t\t\t\t\t\t'expression': {\n\t\t\t\t\t\t\tpattern: /[\\s\\S]+/,\n\t\t\t\t\t\t\talias: 'language-csharp',\n\t\t\t\t\t\t\tinside: 'csharp',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t'string': /[\\s\\S]+/,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t'string': [\n\t\t\t\t{\n\t\t\t\t\tpattern: re(/(^|[^$\\\\])<<0>>/.source, [verbatimString]),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpattern: re(/(^|[^@$\\\\])<<0>>/.source, [regularString]),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t},\n\t\t\t],\n\t\t\t'class-name': [\n\t\t\t\t{\n\t\t\t\t\t// Using static\n\t\t\t\t\t// using static System.Math;\n\t\t\t\t\tpattern: re(/(\\busing\\s+static\\s+)<<0>>(?=\\s*;)/.source, [identifier]),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: typeInside,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// Using alias (type)\n\t\t\t\t\t// using Project = PC.MyCompany.Project;\n\t\t\t\t\tpattern: re(/(\\busing\\s+<<0>>\\s*=\\s*)<<1>>(?=\\s*;)/.source, [\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttypeExpression,\n\t\t\t\t\t]),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: typeInside,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// Using alias (alias)\n\t\t\t\t\t// using Project = PC.MyCompany.Project;\n\t\t\t\t\tpattern: re(/(\\busing\\s+)<<0>>(?=\\s*=)/.source, [name]),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// Type declarations\n\t\t\t\t\t// class Foo<A, B>\n\t\t\t\t\t// interface Foo<out A, B>\n\t\t\t\t\tpattern: re(/(\\b<<0>>\\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: typeInside,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// Single catch exception declaration\n\t\t\t\t\t// catch(Foo)\n\t\t\t\t\t// (things like catch(Foo e) is covered by variable declaration)\n\t\t\t\t\tpattern: re(/(\\bcatch\\s*\\(\\s*)<<0>>/.source, [identifier]),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: typeInside,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// Name of the type parameter of generic constraints\n\t\t\t\t\t// where Foo : class\n\t\t\t\t\tpattern: re(/(\\bwhere\\s+)<<0>>/.source, [name]),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// Casts and checks via as and is.\n\t\t\t\t\t// as Foo<A>, is Bar<B>\n\t\t\t\t\t// (things like if(a is Foo b) is covered by variable declaration)\n\t\t\t\t\tpattern: re(/(\\b(?:is(?:\\s+not)?|as)\\s+)<<0>>/.source, [\n\t\t\t\t\t\ttypeExpressionWithoutTuple,\n\t\t\t\t\t]),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: typeInside,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// Variable, field and parameter declaration\n\t\t\t\t\t// (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)\n\t\t\t\t\tpattern: re(\n\t\t\t\t\t\t/\\b<<0>>(?=\\s+(?!<<1>>|with\\s*\\{)<<2>>(?:\\s*[=,;:{)\\]]|\\s+(?:in|when)\\b))/\n\t\t\t\t\t\t\t.source,\n\t\t\t\t\t\t[typeExpression, nonContextualKeywords, name]\n\t\t\t\t\t),\n\t\t\t\t\tinside: typeInside,\n\t\t\t\t},\n\t\t\t],\n\t\t\t'keyword': keywords,\n\t\t\t// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals\n\t\t\t'number':\n\t\t\t\t/(?:\\b0(?:x[\\da-f_]*[\\da-f]|b[01_]*[01])|(?:\\B\\.\\d+(?:_+\\d+)*|\\b\\d+(?:_+\\d+)*(?:\\.\\d+(?:_+\\d+)*)?)(?:e[-+]?\\d+(?:_+\\d+)*)?)(?:[dflmu]|lu|ul)?\\b/i,\n\t\t\t'operator': />>=?|<<=?|[-=]>|([-+&|])\\1|~|\\?\\?=?|[-+*/%&|^!=<>]=?/,\n\t\t\t'punctuation': /\\?\\.?|::|[{}[\\];(),.:]/,\n\t\t\t$insertBefore: {\n\t\t\t\t'number': {\n\t\t\t\t\t'range': {\n\t\t\t\t\t\tpattern: /\\.\\./,\n\t\t\t\t\t\talias: 'operator',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t'punctuation': {\n\t\t\t\t\t'named-parameter': {\n\t\t\t\t\t\tpattern: re(/([(,]\\s*)<<0>>(?=\\s*:)/.source, [name]),\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\talias: 'punctuation',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t'class-name': {\n\t\t\t\t\t'namespace': {\n\t\t\t\t\t\t// namespace Foo.Bar {}\n\t\t\t\t\t\t// using Foo.Bar;\n\t\t\t\t\t\tpattern: re(\n\t\t\t\t\t\t\t/(\\b(?:namespace|using)\\s+)<<0>>(?:\\s*\\.\\s*<<0>>)*(?=\\s*[;{])/.source,\n\t\t\t\t\t\t\t[name]\n\t\t\t\t\t\t),\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t'punctuation': /\\./,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t'type-expression': {\n\t\t\t\t\t\t// default(Foo), typeof(Foo<Bar>), sizeof(int)\n\t\t\t\t\t\tpattern: re(\n\t\t\t\t\t\t\t/(\\b(?:default|sizeof|typeof)\\s*\\(\\s*(?!\\s))(?:[^()\\s]|\\s(?!\\s)|<<0>>)*(?=\\s*\\))/\n\t\t\t\t\t\t\t\t.source,\n\t\t\t\t\t\t\t[nestedRound]\n\t\t\t\t\t\t),\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\talias: 'class-name',\n\t\t\t\t\t\tinside: typeInside,\n\t\t\t\t\t},\n\t\t\t\t\t'return-type': {\n\t\t\t\t\t\t// Foo<Bar> ForBar(); Foo IFoo.Bar() => 0\n\t\t\t\t\t\t// int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];\n\t\t\t\t\t\t// int Foo => 0; int Foo { get; set } = 0;\n\t\t\t\t\t\tpattern: re(\n\t\t\t\t\t\t\t/<<0>>(?=\\s+(?:<<1>>\\s*(?:=>|[({]|\\.\\s*this\\s*\\[)|this\\s*\\[))/.source,\n\t\t\t\t\t\t\t[typeExpression, identifier]\n\t\t\t\t\t\t),\n\t\t\t\t\t\tinside: typeInside,\n\t\t\t\t\t\talias: 'class-name',\n\t\t\t\t\t},\n\t\t\t\t\t'constructor-invocation': {\n\t\t\t\t\t\t// new List<Foo<Bar[]>> { }\n\t\t\t\t\t\tpattern: re(/(\\bnew\\s+)<<0>>(?=\\s*[[({])/.source, [typeExpression]),\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\tinside: typeInside,\n\t\t\t\t\t\talias: 'class-name',\n\t\t\t\t\t},\n\t\t\t\t\t/*'explicit-implementation': {\n\t\t\t\t\t// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();\n\t\t\t\t\tpattern: replace(/\\b<<0>>(?=\\.<<1>>)/, className, methodOrPropertyDeclaration),\n\t\t\t\t\tinside: classNameInside,\n\t\t\t\t\talias: 'class-name'\n\t\t\t\t},*/\n\t\t\t\t\t'generic-method': {\n\t\t\t\t\t\t// foo<Bar>()\n\t\t\t\t\t\tpattern: re(/<<0>>\\s*<<1>>(?=\\s*\\()/.source, [name, generic]),\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t'function': re(/^<<0>>/.source, [name]),\n\t\t\t\t\t\t\t'generic': {\n\t\t\t\t\t\t\t\tpattern: RegExp(generic),\n\t\t\t\t\t\t\t\talias: 'class-name',\n\t\t\t\t\t\t\t\tinside: typeInside,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t'type-list': {\n\t\t\t\t\t\t// The list of types inherited or of generic constraints\n\t\t\t\t\t\t// class Foo<F> : Bar, IList<FooBar>\n\t\t\t\t\t\t// where F : Bar, IList<int>\n\t\t\t\t\t\tpattern: re(\n\t\t\t\t\t\t\t/\\b((?:<<0>>\\s+<<1>>|record\\s+<<1>>\\s*<<5>>|where\\s+<<2>>)\\s*:\\s*)(?:<<3>>|<<4>>|<<1>>\\s*<<5>>|<<6>>)(?:\\s*,\\s*(?:<<3>>|<<4>>|<<6>>))*(?=\\s*(?:where|[{;]|=>|$))/\n\t\t\t\t\t\t\t\t.source,\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\ttypeDeclarationKeywords,\n\t\t\t\t\t\t\t\tgenericName,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\ttypeExpression,\n\t\t\t\t\t\t\t\tkeywords.source,\n\t\t\t\t\t\t\t\tnestedRound,\n\t\t\t\t\t\t\t\t/\\bnew\\s*\\(\\s*\\)/.source,\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t),\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t'record-arguments': {\n\t\t\t\t\t\t\t\tpattern: re(/(^(?!new\\s*\\()<<0>>\\s*)<<1>>/.source, [\n\t\t\t\t\t\t\t\t\tgenericName,\n\t\t\t\t\t\t\t\t\tnestedRound,\n\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\t\tgreedy: true,\n\t\t\t\t\t\t\t\tinside: 'csharp',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t'keyword': keywords,\n\t\t\t\t\t\t\t'class-name': {\n\t\t\t\t\t\t\t\tpattern: RegExp(typeExpression),\n\t\t\t\t\t\t\t\tgreedy: true,\n\t\t\t\t\t\t\t\tinside: typeInside,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t'punctuation': /[,()]/,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t'preprocessor': {\n\t\t\t\t\t\tpattern: /(^[\\t ]*)#.*/m,\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\talias: 'property',\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t// highlight preprocessor directives as keywords\n\t\t\t\t\t\t\t'directive': {\n\t\t\t\t\t\t\t\tpattern:\n\t\t\t\t\t\t\t\t\t/(#)\\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\\b/,\n\t\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\t\talias: 'keyword',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t'attribute': {\n\t\t\t\t\t\t// Attributes\n\t\t\t\t\t\t// [Foo], [Foo(1), Bar(2, Prop = \"foo\")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]\n\t\t\t\t\t\tpattern: re(\n\t\t\t\t\t\t\t/((?:^|[^\\s\\w>)?])\\s*\\[\\s*)(?:<<0>>\\s*:\\s*)?<<1>>(?:\\s*,\\s*<<1>>)*(?=\\s*\\])/\n\t\t\t\t\t\t\t\t.source,\n\t\t\t\t\t\t\t[attrTarget, attr]\n\t\t\t\t\t\t),\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\tgreedy: true,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t'target': {\n\t\t\t\t\t\t\t\tpattern: re(/^<<0>>(?=\\s*:)/.source, [attrTarget]),\n\t\t\t\t\t\t\t\talias: 'keyword',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t'attribute-arguments': {\n\t\t\t\t\t\t\t\tpattern: re(/\\(<<0>>*\\)/.source, [roundExpression]),\n\t\t\t\t\t\t\t\tinside: 'csharp',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t'class-name': {\n\t\t\t\t\t\t\t\tpattern: RegExp(identifier),\n\t\t\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t\t\t'punctuation': /\\./,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t'punctuation': /[:,]/,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t'string': {\n\t\t\t\t\t'interpolation-string': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: re(\n\t\t\t\t\t\t\t\t/(^|[^\\\\])(?:\\$@|@\\$)\"(?:\"\"|\\\\[\\s\\S]|\\{\\{|<<0>>|[^\\\\{\"])*\"/.source,\n\t\t\t\t\t\t\t\t[mInterpolation]\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\tgreedy: true,\n\t\t\t\t\t\t\tinside: createInterpolationInside(mInterpolation, mInterpolationRound),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: re(/(^|[^@\\\\])\\$\"(?:\\\\.|\\{\\{|<<0>>|[^\\\\\"{])*\"/.source, [\n\t\t\t\t\t\t\t\tsInterpolation,\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\tgreedy: true,\n\t\t\t\t\t\t\tinside: createInterpolationInside(sInterpolation, sInterpolationRound),\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t'char': {\n\t\t\t\t\t\tpattern: RegExp(character),\n\t\t\t\t\t\tgreedy: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t'comment': {\n\t\t\t\t\t'doc-comment': /** @type {import('../types.d.ts').GrammarTokens} */ (\n\t\t\t\t\t\tgetOptionalLanguage('xml-doc')\n\t\t\t\t\t)?.slash,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n};\n"],"names":["replace","pattern","replacements","m","index","re","flags","RegExp","nested","depthLog2","i","csharp","id","base","clike","optional","alias","grammar","getOptionalLanguage","keywordKinds","keywordsToPattern","words","trim","typeDeclarationKeywords","keywords","nonTypeKeywords","nonContextualKeywords","generic","nestedRound","name","genericName","identifier","array","typeExpressionWithoutTuple","tupleElement","tuple","typeExpression","typeInside","keyword","punctuation","character","regularString","regularStringOrCharacter","regularStringCharacterOrComment","roundExpression","attrTarget","attr","formatString","mInterpolationRound","mInterpolation","sInterpolationRound","sInterpolation","createInterpolationInside","interpolation","interpolationRound","lookbehind","inside","expression","string","greedy","number","operator","$insertBefore","range","namespace","function","source","preprocessor","directive","attribute","target","char","comment","slash"],"mappings":"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"}