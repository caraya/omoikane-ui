import{h as e}from"./util-DdJteTVJ.js";import{T as t}from"./token-Dozwbq7Q.js";import{d as s,b as n,i as r,a as i,c as a,e as o}from"./insert-CpDsPTVw.js";import{a as l}from"./iterables-BnTatl6v.js";const g="undefined"!=typeof document&&"undefined"!=typeof window,h=g?document.currentScript:null,c="Object"===globalThis.Prism?.constructor?.name?globalThis.Prism:{};function u(e){const t=e.replace(/-([a-z])/g,(e=>e[1].toUpperCase()));return t in c?c[t]:e in c?c[e]:g?h?.dataset[t]??document.querySelector(`[data-prism-${e}]`)?.getAttribute("data-prism-"+e):void 0}function d(e,t){const s=u(e);return null==s?t:!(!1===s||"false"===s)}function f(e){const t=u(e);return null==t||!1===t||"false"===t?[]:"string"==typeof t?t.split(",").map((e=>e.trim())):Array.isArray(t)?t:[]}const p={manual:d("manual",!g),silent:d("silent",!1),languages:f("languages"),plugins:f("plugins"),languagePath:u("language-path")??"./languages/",pluginPath:u("plugin-path")??"./plugins/"};function m(){return new Promise((e=>{"function"==typeof requestAnimationFrame?requestAnimationFrame(e):"function"==typeof setImmediate?setImmediate(e):setTimeout(e,0)}))}async function y(e){return Promise.allSettled(e).then((t=>e.length>0&&e.length!==t.length?y(e):t.map((e=>"fulfilled"===e.status?e.value:null))))}function v(e={}){const t=this??T,{root:s,async:n,callback:r}=e,i={callback:r,root:s??document,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};t.hooks.run("before-highlightall",i),i.elements=[...i.root.querySelectorAll(i.selector)],t.hooks.run("before-all-elements-highlight",i);for(const e of i.elements)t.highlightElement(e,{async:n,callback:i.callback})}const $=/(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;function A(e){let t=e;for(;t;t=t.parentElement){const e=$.exec(t.className);if(e)return e[1].toLowerCase()}return"none"}function b(e,t){e.className=e.className.replace(RegExp($,"gi"),""),e.classList.add("language-"+t)}function w(e,t,s=!1){return e?.closest(`.${t}, .no-${t}`)?.classList?.contains(t)??s}function x(e){const t=e.parentElement;if(t&&/pre/i.test(t.nodeName))return t}function k(t,s={}){const n=this??T,{async:r,callback:i}=s,a=A(t),o=n.languageRegistry.getLanguage(a)?.resolvedGrammar;b(t,a);let l=t.parentElement;l&&"pre"===l.nodeName.toLowerCase()&&b(l,a);const g={element:t,language:a,grammar:o,code:t.textContent},h=e=>{g.highlightedCode=e,n.hooks.run("before-insert",g),g.element.innerHTML=g.highlightedCode,n.hooks.run("after-highlight",g),n.hooks.run("complete",g),i?.(g.element)};if(n.hooks.run("before-sanity-check",g),l=g.element.parentElement,l&&"pre"===l.nodeName.toLowerCase()&&!l.hasAttribute("tabindex")&&l.setAttribute("tabindex","0"),!g.code)return n.hooks.run("complete",g),void i?.(g.element);n.hooks.run("before-highlight",g),g.grammar?r?r({language:g.language,code:g.code,grammar:g.grammar}).then(h,n.config.errorHandler):h(n.highlight(g.code,g.language,{grammar:g.grammar})):h(e(g.code))}function L(t,s,n){if("string"==typeof t)return e(t);if(Array.isArray(t)){let e="";return t.forEach((t=>{e+=L(t,s,n)})),e}const r={type:t.type,content:L(t.content,s,n),tag:"span",classes:["token",t.type],attributes:{},language:s},i=t.alias;i&&(Array.isArray(i)?r.classes.push(...i):r.classes.push(i)),n.run("wrap",r);let a="";for(const e in r.attributes)a+=" "+e+'="'+(r.attributes[e]||"").replace(/"/g,"&quot;")+'"';return"<"+r.tag+' class="'+r.classes.join(" ")+'"'+a+">"+r.content+"</"+r.tag+">"}function R(e,t,s){const n=this??T,r={code:e,grammar:s?.grammar??n.languageRegistry.getLanguage(t)?.resolvedGrammar,language:t};if(n.hooks.run("before-tokenize",r),!r.grammar)throw Error('The language "'+r.language+'" has no grammar.');return r.tokens=n.tokenize(r.code,r.grammar),n.hooks.run("after-tokenize",r),L(r.tokens,r.language,n.hooks)}class LinkedList{head;tail;length;constructor(){const e={value:null,prev:null,next:null},t={value:null,prev:e,next:null};e.next=t,this.head=e,this.tail=t,this.length=0}addAfter(e,t){const s=e.next,n={value:t,prev:e,next:s};return e.next=n,s.prev=n,this.length++,n}removeRange(e,t){let s=e.next,n=0;for(;n<t&&null!==s.next;n++)s=s.next;e.next=s,s.prev=e,this.length-=n}toArray(){const e=[];let t=this.head.next;for(;null!==t.next;)e.push(t.value),t=t.next;return e}}function P(e){const t=this??T;let s=e??void 0;if("string"==typeof s&&(s=t.languageRegistry.getLanguage(s)?.resolvedGrammar),"object"==typeof s&&s.$rest){const e=P.call(t,s.$rest)??{};"object"==typeof e&&(s={...s,...e}),delete s.$rest}return s}function E(e,s,n,r,i,a){const o=this??T;n=P.call(o,n);for(const l in n){const g=n[l];if(!n.hasOwnProperty(l)||l.startsWith("$")||!g)continue;const h=Array.isArray(g)?g:[g];for(let g=0;g<h.length;++g){if(a&&a.cause===`${l},${g}`)return;const c=q(h[g]);let{pattern:u,lookbehind:d=!1,greedy:f=!1,alias:p,inside:m}=c;const y=P.call(o,m);f&&!u.global&&(c.pattern=u=RegExp(u.source,u.flags+"g"));for(let h=r.next,c=i;null!==h.next&&!(a&&c>=a.reach);c+=h.value.length,h=h.next){let r=h.value;if(s.length>e.length)return;if(r instanceof t)continue;let i,m=1;if(f){if(i=j(u,c,e,d),!i||i.index>=e.length)break;const s=i.index,n=i.index+i[0].length;let a=c;for(a+=h.value.length;s>=a;){if(h=h.next,null===h.next)throw Error("The linked list and the actual text have become de-synced");a+=h.value.length}if(a-=h.value.length,c=a,h.value instanceof t)continue;let o=h;for(;null!==o.next&&(a<n||"string"==typeof o.value);o=o.next)m++,a+=o.value.length;m--,r=e.slice(c,a),i.index-=c}else if(i=j(u,0,r,d),!i)continue;const v=i.index,$=i[0],A=r.slice(0,v),b=r.slice(v+$.length),w=c+r.length;a&&w>a.reach&&(a.reach=w);let x=h.prev;A&&(x=s.addAfter(x,A),c+=A.length),s.removeRange(x,m);const k=new t(l,y?C.call(o,$,y):$,p,$);if(h=s.addAfter(x,k),b&&s.addAfter(h,b),m>1){const t={cause:`${l},${g}`,reach:w};E.call(o,e,s,n,h.prev,c,t),a&&t.reach>a.reach&&(a.reach=t.reach)}}}}}function j(e,t,s,n){e.lastIndex=t;const r=e.exec(s);if(r&&n&&r[1]){const e=r[1].length;r.index+=e,r[0]=r[0].slice(e)}return r}function q(e){return e.pattern?e:{pattern:e}}function C(e,t){const s=this??T,n=t.$tokenize;if(n)return n(e,t,s);const r=new LinkedList;return r.addAfter(r.head,e),E.call(s,e,r,t,r.head,0),r.toArray()}class Hooks{_all={};add(e,t){if(Array.isArray(e))for(const s of e)this.add(s,t);else if("object"==typeof e){const t=e;for(const e in t){const s=t[e];s&&this.add(e,s)}}else(this._all[e]??=[]).push(t);return()=>{this.remove(e,t)}}remove(e,t){if(Array.isArray(e))for(const s of e)this.remove(s,t);else if("object"==typeof e)for(const s in e)this.remove(s,t);else{const s=this._all[e]?.indexOf(t);s>-1&&this._all[e].splice(s,1)}}run(e,t){const s=this._all[e],n=t?.this??t?.context??t;if(s&&s.length)for(const e of s)e.call(n,t)}}class ComponentRegistry extends EventTarget{static type="unknown";cache={};loading={};#e=[];ready;path;prism;options;constructor(e){super(),this.options=e;let{path:t,preload:s,prism:n}=e;this.prism=n,t=t.endsWith("/")?t:t+"/",this.path=t,s&&this.loadAll(s),this.ready=y(this.#e)}async whenDefined(e){if(this.cache[e])return this.cache[e];if(void 0!==this.loading[e])return this.loading[e];const t=this.constructor;return new Promise((s=>{const n=t=>{t.detail.id===e&&(s(t.detail.component),this.removeEventListener("add",n))};this.addEventListener("add"+t.type,n)}))}add(e,t=e.id,s){const n=this.constructor;if(void 0!==this.loading[t]){const e=this.#e.indexOf(this.loading[t]);e>-1&&this.#e.splice(e,1),delete this.loading[t]}return!(this.cache[t]&&!s?.force||(this.cache[t]=e,this.dispatchEvent(new CustomEvent("add",{detail:{id:t,type:n.type,component:e}})),this.dispatchEvent(new CustomEvent("add"+n.type,{detail:{id:t,component:e}})),0))}has(e){return void 0!==this.cache[e]}get(e){return this.cache[e]??null}load(e){if(this.cache[e])return this.cache[e];if(void 0!==this.loading[e])return this.loading[e];const t=import(this.path+e+".js").then((t=>{const s=t.default??t;return this.add(s,e),s})).catch((e=>(console.error(e),null)));return this.loading[e]=t,this.#e.push(t),t}loadAll(e){return Array.isArray(e)||(e=[e]),e.map((e=>this.load(e)))}}function G(e,t){const r=s(e);for(const e in t)"string"!=typeof e||e.startsWith("$")||(r[e]=t[e]);if(t.$insertBefore&&(r.$insertBefore=n(r.$insertBefore??{},t.$insertBefore)),t.$insertAfter&&(r.$insertAfter=n(r.$insertAfter??{},t.$insertAfter)),t.$insert)for(const e in t.$insert){const s=t.$insert[e],{$before:n,$after:i,...a}=s,o=n||i,l=n?"$insertBefore":"$insertAfter";if(r[l]??={},Array.isArray(o))for(const t of o)r[l][t][e]=a;else o?(r[l][o]??={})[e]=a:r[e]=a}return t.$delete&&(r.$delete?r.$delete.push(...t.$delete):r.$delete=[...t.$delete]),t.$merge&&(r.$merge=n(r.$merge??{},t.$merge)),r}class List extends Set{get length(){return this.size}addAll(e){if(!e)return this;for(const t of l(e))this.add(t);return this}}class Language extends EventTarget{def;registry;require=new List;optional=new List;languages={};readyState=0;constructor(e,t){if(super(),this.def=e,this.registry=t,this.def.base&&this.require.add(this.def.base),this.def.require&&this.require.addAll(this.def.require),this.def.optional&&(this.optional.addAll(this.def.optional),this.optional.size>0))for(const e of this.optional)this.registry.has(e)||this.registry.whenDefined(e).then((()=>{}));for(const e of this.require)this.registry.add(e),o(this.languages,e.id,(()=>{const t=this.registry.peek(e);return t?t.resolvedGrammar:this.registry.getLanguage(e.id).resolvedGrammar}));for(const e of this.optional)o(this.languages,e,(()=>this.registry.getLanguage(e).resolvedGrammar),this.registry.peek(e)??this.registry.whenDefined(e))}resolve(){}get id(){return this.def.id}get alias(){return this.def.alias?Array.isArray(this.def.alias)?this.def.alias:[this.def.alias]:[]}get base(){if(!this.def.base)return null;const e=this.def.base;return this.registry.peek(e)||this.registry.getLanguage(e.id)}get grammar(){const e=this.def;let{grammar:t}=e;const n=this.base;if("function"==typeof t){const e={...n&&{get base(){return n.resolvedGrammar}},languages:this.languages,extend:(e,t)=>G(this.languages[e],t),getOptionalLanguage:e=>{const t=this.languages[e]??this.registry.getLanguage(e);return t?.resolvedGrammar??t},whenDefined:e=>this.registry.whenDefined(e)};t=t.call(this,e)}return n&&(t=G(n.grammar,t)),e.grammar===t&&(t=s(t)),this.grammar=t}set grammar(e){this.readyState=2,Object.defineProperty(this,"grammar",{value:e,writable:!0})}get resolvedGrammar(){const e=((e,t=e)=>{if(t.$insertBefore){for(const s in t.$insertBefore){const n=t.$insertBefore[s];if(s?.includes("/")){let t=s.split("/");const i=t.pop();t=t.flatMap((e=>[e,"inside"]));const a=t.reduce(((e,t)=>e?.[t]),e);a&&r(a,i,n)}else n&&r(e,s,n)}delete e.$insertBefore}if(t.$insertAfter){for(const s in t.$insertAfter){const n=t.$insertAfter[s];if(s?.includes("/")){let t=s.split("/");const r=t.pop();t=t.flatMap((e=>[e,"inside"]));const a=t.reduce(((e,t)=>e?.[t]),e);a&&i(a,r,n)}else n&&i(e,s,n)}delete e.$insertAfter}if(t.$delete){for(const s of t.$delete)delete e[s];delete e.$delete}if(t.$merge){for(const s in t.$merge){const n=t.$merge[s];e[s]?a(e[s],n):e[s]=n}delete e.$merge}return e})(this.grammar);return this.resolvedGrammar=e}set resolvedGrammar(e){this.readyState=3,Object.defineProperty(this,"resolvedGrammar",{value:e,writable:!0})}}class LanguageRegistry extends ComponentRegistry{static type="language";aliases={};instances={};defs=new WeakMap;add(e){const t=super.add(e);if(t){if(e.alias){const t=e.id;if("string"==typeof e.alias)this.aliases[e.alias]=t;else if(Array.isArray(e.alias))for(const s of e.alias)this.aliases[s]=t}e.effect?.(this.prism)}return t}resolveRef(e){if(e instanceof Language)return{id:e.id,def:e.def,language:e};let t,s;if("object"==typeof e)s=e,t=s.id;else{if("string"!=typeof e)throw Error("Invalid argument type: "+e);t=e}return t=this.aliases[t]??t,s??=this.cache[t],{id:t,def:s,language:this.instances[t]}}peek(e){const{id:t,def:s,language:n}=this.resolveRef(e);return n||(this.defs.has(s)?this.defs.get(s)??null:this.instances[t]?this.instances[t]:null)}getLanguage(e){const t=this.peek(e);if(t instanceof Language)return t;const{id:s,def:n}=this.resolveRef(e);if(!this.cache[s])return null;const r=new Language(n,this);return this.defs.set(n,r),this.instances[n.id]=r,r}}class Plugin extends EventTarget{def;registry;require=new List;constructor(e,t){super(),this.def=e,this.registry=t,this.def.require&&this.require.addAll(this.def.require);for(const e of this.require)e.grammar?this.registry.prism.languageRegistry.add(e):this.registry.add(e)}get id(){return this.def.id}get plugin(){return this.def.plugin?this.plugin=this.def.plugin(this.registry.prism):null}set plugin(e){Object.defineProperty(this,"plugin",{value:e,writable:!0})}get effect(){return this.def.effect}}class PluginRegistry extends ComponentRegistry{static type="plugin";instances={};defs=new WeakMap;add(e){const t=super.add(e);if(t){const t=new Plugin(e,this);this.defs.set(e,t),this.instances[e.id]=t,t.effect?.(this.prism)}return t}peek(e){if(e instanceof Plugin)return e;if("object"==typeof e)return this.defs.get(e)??null;if("string"==typeof e)return this.instances[e]??null;throw Error("Invalid argument type: "+e)}}class Prism{hooks=new Hooks;languageRegistry;pluginRegistry;config=p;waitFor=[m()];ready=y(this.waitFor);constructor(e={}){this.config=Object.assign({},p,e),this.config.errorHandler??=this.config.silent?()=>{}:console.error;const t=this.config.errorHandler;this.languageRegistry=new LanguageRegistry({path:this.config.languagePath,preload:this.config.languages,prism:this}),this.pluginRegistry=new PluginRegistry({path:this.config.pluginPath,prism:this}),this.languagesReady=this.languageRegistry.ready,this.waitFor.push(this.languagesReady);const s=this.config.plugins;if(s&&s.length>0){const e=this.languagesReady.then((()=>this.waitFor.push(...this.pluginRegistry.loadAll(s)))).catch(t);this.waitFor.push(e)}this.config.manual||(this.waitFor.push(((e=globalThis.document)=>{if(!e)return Promise.reject();const t=e.currentScript,s=e.readyState;return"loading"===s||"interactive"===s&&t&&t.defer&&!t.async?new Promise((t=>{e.addEventListener("DOMContentLoaded",t,{once:!0})})):Promise.resolve()})()),this.ready.then((()=>this.highlightAll())).catch(t))}get languages(){return this.languageRegistry.cache}get plugins(){return this.pluginRegistry.cache}async loadLanguage(e){return await this.languageRegistry.load(e)}async loadPlugin(e){return await this.languagesReady,await this.pluginRegistry.load(e)}highlightAll(e={}){return v.call(this,e)}highlightElement(e,t={}){return k.call(this,e,t)}highlight(e,t,s={}){return R.call(this,e,t,s)}tokenize(e,t){return C.call(this,e,t)}}const T=new Prism;export{Prism as P,A as a,G as e,x as g,w as i,T as p,P as r,b as s};
